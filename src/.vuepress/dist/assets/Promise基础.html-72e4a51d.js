import{_ as s,W as a,X as e,$ as t,a1 as n}from"./framework-331092d5.js";const p="/assets/image-20230720170035179-972507bd.png",i={},o=n('<h1 id="promise对象" tabindex="-1"><a class="header-anchor" href="#promise对象" aria-hidden="true">#</a> Promise对象</h1><h2 id="promise概念" tabindex="-1"><a class="header-anchor" href="#promise概念" aria-hidden="true">#</a> Promise概念</h2><p><strong><code>Promise</code></strong> 对象表示异步操作最终的完成（或失败）以及其结果值。</p><p>一个 <strong><code>Promise</code></strong> 是一个代理，它代表一个在创建 promise 时不一定已知的值。它允许你将处理程序与异步操作的最终成功值或失败原因关联起来。这使得异步方法可以像同步方法一样返回值：异步方法不会立即返回最终值，而是返回一个 <em>promise</em>，以便在将来的某个时间点提供该值。</p><p>一个待定的 Promise <em>最终状态</em>可以是<em>已兑现</em>并返回一个值，或者是<em>已拒绝</em>并返回一个原因（错误）。当其中任意一种情况发生时，通过 Promise 的 <code>then</code> 方法串联的处理程序将被调用。如果绑定相应处理程序时 Promise 已经兑现或拒绝，这处理程序将被立即调用，因此在异步操作完成和绑定处理程序之间不存在竞态条件。</p><p>如果一个 Promise 已经被兑现或拒绝，即不再处于待定状态，那么则称之为已<em>敲定（settled）</em>。</p>',6),l=n(`<h2 id="为什么要使用promise" tabindex="-1"><a class="header-anchor" href="#为什么要使用promise" aria-hidden="true">#</a> 为什么要使用Promise</h2><ul><li><p>指定回调函数的方式更加灵活</p><ul><li>不使用promise的回调函数：必须在启动异步任务前指定</li><li>使用promise的回调函数：启动异步任务=&gt;返回promie对象=&gt;给promise对象绑定回调函数（甚至可以在异步任务结束后指定/多个）</li></ul></li><li><p>支持链式调用，可以解决回调地狱问题</p><ul><li><p>什么是回调地狱</p><p>回调函数嵌套调用，外部回调函数异步执行的结果是嵌套的回调执行的条件</p></li><li><p>回调地狱的缺点</p><p>不便于阅读、不便于异常处理、不利于维护</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">//有多个异步任务，要求需要同时拿到所有异步任务的结果，下边就是用回调地狱</span>
$<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&quot;url&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">res1</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    conosle<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res1<span class="token punctuation">)</span>
    $<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&quot;url+res1&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">res2</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        conosle<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res2<span class="token punctuation">)</span>
        $<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&quot;url+res2&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">res3</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            conosle<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res3<span class="token punctuation">)</span>
            $<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&quot;url+res3&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">res4</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                conosle<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res4<span class="token punctuation">)</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>解决方案</p><p>promise链式调用</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> myPromise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">&quot;foo&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">300</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

myPromise
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>handleFulfilledA<span class="token punctuation">,</span> handleRejectedA<span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>handleFulfilledB<span class="token punctuation">,</span> handleRejectedB<span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>handleFulfilledC<span class="token punctuation">,</span> handleRejectedC<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li></ul><h2 id="异步编程" tabindex="-1"><a class="header-anchor" href="#异步编程" aria-hidden="true">#</a> 异步编程</h2><ul><li>文件操作</li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;fs&#39;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span><span class="token string">&#39;./index.html&#39;</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span>data</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>数据库操作</li><li>AJAX</li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code> $<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&#39;/server&#39;</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>定时器</li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="promise的状态" tabindex="-1"><a class="header-anchor" href="#promise的状态" aria-hidden="true">#</a> Promise的状态</h2><ul><li>一个 <code>Promise</code> 必然处于以下几种状态之一： <ul><li><em>待定（pending）</em>：初始状态，既没有被兑现，也没有被拒绝。</li><li><em>已兑现（fulfilled）</em>：意味着操作成功完成。</li><li><em>已拒绝（rejected）</em>：意味着操作失败。</li></ul></li></ul><h2 id="promise-对象的值" tabindex="-1"><a class="header-anchor" href="#promise-对象的值" aria-hidden="true">#</a> Promise 对象的值</h2><p>实例对象中的另一个属性 『PromiseResult』</p><p>保存着异步任务『成功 / 失败』的结果</p><ul><li>resolve</li><li>reject</li></ul><h2 id="promise的基本流程" tabindex="-1"><a class="header-anchor" href="#promise的基本流程" aria-hidden="true">#</a> promise的基本流程</h2><figure><img src="`+p+'" alt="image-20230720170035179" tabindex="0" loading="lazy"><figcaption>image-20230720170035179</figcaption></figure><h2 id="如何使用promise" tabindex="-1"><a class="header-anchor" href="#如何使用promise" aria-hidden="true">#</a> 如何使用Promise</h2><ul><li>Promise构造函数：Promise(<code>excutor</code>){}</li><li>executor：执行器 (resolve,reject)=&gt;{} <ul><li>resolve函数：内部定义成功时我们调用的函数value=&gt;{}</li><li>reject函数：内部定义失败时我们调用的函数reason=&gt;{}</li></ul></li></ul><p><strong>说明：executor会在Promise内部立即同步调用，异步操作在执行器中执行</strong></p><ul><li><p><code>Promise.prototype.then</code>方法：(onResolved,onRejected)=&gt;{}</p><ul><li>onResolved函数：成功的回调函数(value)=&gt;{}</li><li>onRejected函数：失败的回调函数(reason)=&gt;{}</li></ul><p><strong>说明：指定用于得到成功value的成功回调和用于得到失败reason的失败回调返回一个新的promise对象</strong></p></li><li><p><code>Promise.prototype.catch</code>方法：(onRejected)=&gt;{} * onRejected函数：失败的回调函数（resson）=&gt;{}</p></li></ul><p>​ <strong>说明：then的语法糖，相当于：then(undefined,onRejected)</strong></p><ul><li><code>Promise.resolve</code>方法：(value)=&gt;{} <ul><li>value:成功的数据或promise对象</li></ul></li></ul><p>​ <strong>说明：返回一个成功/失败的promise对象（当传入promise对象是，该方法的返回值与传入对象的结果一致）</strong></p><ul><li><p><code>Promise.reject</code>方法：(reason)=&gt;{}</p><ul><li>reason:失败的原因</li></ul><p><strong>说明：返回一个失败的promise对象（不管传什么都是返回一个失败的promise对象）</strong></p></li><li><p><code>Promise.all</code>方法：(promises)=&gt;{}</p></li><li><p>promises:包含n个promise的数组</p></li></ul><p><strong>说明：返回一个新的promise,只有所有的promise都成功才成功，只要有一个失败了就直接失败</strong></p><ul><li><p><code>Promise.race</code>方法：(promises)=&gt;{}</p></li><li><p>promises:包含n个promise的数组</p></li></ul><p><strong>说明：返回一个新的promise,第一个完成的promise的结果状态就是最终的结果状态</strong></p><h2 id="promise的几个关键问题" tabindex="-1"><a class="header-anchor" href="#promise的几个关键问题" aria-hidden="true">#</a> Promise的几个关键问题</h2><h3 id="如何改变promise的状态" tabindex="-1"><a class="header-anchor" href="#如何改变promise的状态" aria-hidden="true">#</a> 如何改变promise的状态？</h3><ul><li>resolve(value): 如果当前是pending就会变为resolved</li><li>reject(reason小：如果当前是pending就会变为rejected</li><li>抛出异常：如果当前是pending就会变为rejected</li></ul><h3 id="一个promise指定多个成功-失败回调函数-都会调用吗" tabindex="-1"><a class="header-anchor" href="#一个promise指定多个成功-失败回调函数-都会调用吗" aria-hidden="true">#</a> 一个promise指定多个成功/失败回调函数，都会调用吗？</h3><ul><li>当promise改变为对应状态时都会调用</li></ul><h3 id="改变promise状态和指定回调函数谁先谁后" tabindex="-1"><a class="header-anchor" href="#改变promise状态和指定回调函数谁先谁后" aria-hidden="true">#</a> 改变promise状态和指定回调函数谁先谁后？</h3><ul><li>都有可能，正常情况下是先指定回调再改变状态(因为一般promise对象里是要处理异步任务的，所以会在指定回调函数执行了才会改变promise状态)，但也可以先改状态再指定回调，如2中所示。</li><li>如何先改状态再指定回调？ <ol><li>在执行器中直接调用resolve()/reject()</li><li>延迟更长时间才调用</li></ol></li><li>什么时候才能得到数据？ <ol><li>如果先指定的回调，那当状态发生改变时，回调函数就会调用，得到数据</li><li>如果先改变的状态，那当指定回调时，回调函数就会调用，得到数据</li></ol></li></ul><h3 id="promise-then-方法的返回结果特点" tabindex="-1"><a class="header-anchor" href="#promise-then-方法的返回结果特点" aria-hidden="true">#</a> Promise.then()方法的返回结果特点</h3><ul><li>简单表达：由then()指定的回调函数执行的结果决定</li><li>详细表达： <ul><li>如果抛出异常，新promise状态变为rejected,reason为抛出的异常</li><li>如果返回的是非promise的任意值，新promise的结果变为resolved,value为返回的值</li><li>如果返回的是另一个新promise,此promise的结果就会成为新promise的结果</li></ul></li></ul><h3 id="promise如何串连多个操作任务" tabindex="-1"><a class="header-anchor" href="#promise如何串连多个操作任务" aria-hidden="true">#</a> promise如何串连多个操作任务？</h3><ul><li>promise的then()返回一个新的promise,可以开成then()的链式调用</li><li>通过then的链式调用串连多个同步/异步任务</li></ul><h3 id="promise异常传透" tabindex="-1"><a class="header-anchor" href="#promise异常传透" aria-hidden="true">#</a> promise异常传透？</h3><ul><li>当使用promise的then链式调用时，可以在最后指定失败的回调，</li><li>前面任何操作出了异常，都会传到最后失败的回调中处理</li></ul><h3 id="promise异常传透-1" tabindex="-1"><a class="header-anchor" href="#promise异常传透-1" aria-hidden="true">#</a> promise异常传透</h3><ul><li>当使用promise的then链式调用时，可以在最后指定失败的回调</li><li>前面任何操作出了异常，都会传到最后失败的回调中处理</li></ul><h3 id="中断promise链" tabindex="-1"><a class="header-anchor" href="#中断promise链" aria-hidden="true">#</a> 中断promise链</h3><ul><li>当使用promise的then链式调用时，在中间中断，不再调用后面的回调函数</li><li>办法：在回调函数中返回一个pendding状态的promise对象</li></ul>',45);function c(r,u){return a(),e("div",null,[o,t(" more "),l])}const m=s(i,[["render",c],["__file","Promise基础.html.vue"]]);export{m as default};
