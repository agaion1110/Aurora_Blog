---
icon: edit
date: 2023-10-16
category:
  - 面试考核总结
tag:
  - 浏览器机制
  - 面试题
star: false
sticky: false
copy.disableCopy: true
---

# 模拟面试 - 1

<!-- more -->

## 1. H5,C3都有哪些新特性

HTML5新特性：

1. 语义化标签：HTML5引入了一些新的语义化标签，如`<header>`、`<nav>`、`<section>`、`<article>`等，使开发者能够更清晰地描述页面结构。
2. 视频和音频支持：HTML5提供了内置的`<video>`和`<audio>`标签，使得在网页中嵌入视频和音频变得更加简单，不再需要依赖第三方插件。
3. Canvas绘图：HTML5的`<canvas>`元素允许开发者使用JavaScript进行动态绘图，包括图形、动画和数据可视化等。
4. 本地存储：HTML5引入了本地存储机制，如localStorage和sessionStorage，可以在浏览器端存储数据，提供了更好的离线应用支持。
5. 表单增强：HTML5为表单元素提供了一些新的属性和输入类型，例如日期选择器、邮箱验证、数字输入等，提高了表单的用户体验和数据验证功能。

CSS3的新特性：

1. 布局模块：CSS3引入了一些新的布局模块，如弹性盒子（Flexbox）和网格布局（Grid Layout），使得网页布局更加灵活和响应式。
2. 过渡和动画：CSS3提供了过渡（transition）和动画（animation）属性，使开发者能够通过CSS实现页面元素的平滑过渡和动画效果，而无需依赖JavaScript或Flash等技术。
3. 边框和阴影效果：CSS3引入了一系列新的边框样式和阴影效果，使开发者能够轻松创建更加复杂和独特的界面设计。
4. 字体和文本效果：CSS3增加了对Web字体的支持，使开发者能够在网页中使用自定义字体，同时还提供了一些新的文本效果，如文字阴影、文字渐变等。
5. 媒体查询：CSS3的媒体查询功能允许根据设备的特性和屏幕大小应用不同的样式，实现响应式设计，使网页能够在不同的设备上自适应。

## 2. 数据持久化

在前端项目中，数据持久化是指将应用程序中的数据保存到持久存储介质中，以便在刷新页面、关闭浏览器或重新打开应用程序时能够保留数据状态。常见的数据持久化方法包括本地存储、Cookie、IndexedDB、Web SQL、以及与后端进行数据交互等。

1. **本地存储（Local Storage）**：本地存储是Web浏览器提供的一种机制，允许前端应用将数据以键值对的形式存储在用户的浏览器中。通过使用`localStorage`对象，可以将数据保存在浏览器的本地存储区域，并在之后从该区域检索数据。本地存储是一种简单且易于使用的持久化方法，适用于存储较小量的数据。
2. **Cookie**：Cookie是一种在浏览器中存储数据的机制，它由服务器发送给浏览器，并由浏览器保存。通过使用JavaScript的`document.cookie`API，可以设置、获取和删除Cookie。Cookie可以存储少量的数据，但其大小限制为4KB，并且每次请求都会将Cookie发送到服务器端，因此适合存储一些简单的标识信息或会话相关的数据。
3. **IndexedDB**：IndexedDB是浏览器提供的一种高级的客户端数据库，可以在浏览器中存储结构化数据。它提供了一个类似于关系数据库的API，支持事务操作和索引查询。IndexedDB使用异步操作，适用于存储大量数据和执行复杂查询的场景。
4. **Web SQL**：Web SQL是一种基于SQL的浏览器数据库，允许在浏览器中创建和操作关系型数据库。尽管Web SQL在规范中已被废弃，但在某些浏览器中仍然存在，并且可以用于存储和查询结构化数据。

需要根据具体需求和场景选择适合的数据持久化方法。对于简单的数据存储需求，本地存储或Cookie可能足够；而对于复杂的数据结构和大量数据的情况，IndexedDB或与后端交互可能更合适。

## 3.es6新特性

1. **块级作用域和`let`、`const`关键字**：ES6引入了`let`和`const`关键字，用于声明块级作用域的变量和常量，解决了旧版本中只有函数作用域和全局作用域的限制。
2. **箭头函数**：箭头函数是一种更简洁的函数定义语法，可以更方便地定义匿名函数和处理函数的作用域问题。
3. **模板字符串**：ES6提供了模板字符串，可以使用反引号(`)来定义多行字符串和插入变量，使字符串拼接更加简洁和可读。
4. **解构赋值**：解构赋值语法允许从数组或对象中提取值并赋给变量，提供了一种便捷的方式来访问和操作复杂数据结构的成员。
5. **默认参数**：ES6允许在函数定义中为参数设置默认值，简化了函数调用时的参数处理和传递。
6. **扩展运算符**：扩展运算符（`...`）用于展开数组或对象，可以方便地进行数组合并、复制和函数参数的传递。
7. **类和模块**：ES6引入了类（class）和模块（module）的语法，提供了更接近传统面向对象编程的方式来定义和组织代码。
8. **迭代器和生成器**：ES6引入了迭代器（Iterator）和生成器（Generator）的概念，使得遍历和生成数据序列更加简单和灵活。
9. **Promise**：Promise是一种处理异步操作的方式，ES6将其纳入了语言标准，提供了一种更优雅和可靠的处理异步任务的机制。
10. **模块化导入和导出**：ES6提供了更强大和灵活的模块化系统，使用`import`和`export`关键字来导入和导出模块的功能和变量。
11. **Set和Map**：ES6引入了Set和Map数据结构，提供了更方便和高效的方式来管理和操作数据集合。

## 4.var let const区别

`var`：`var` 是在 ES5 中引入的变量声明关键字。它具有以下特点：

- 函数作用域：`var` 声明的变量的作用域是整个函数体内。如果在函数内部使用 `var` 声明变量，则在函数外部无法访问该变量。
- 变量提升（Hoisting）：`var` 声明的变量会被提升到函数作用域的顶部。这意味着你可以在变量声明之前访问变量，但其值为 `undefined`。
- 可重复声明：在同一个作用域内，使用 `var` 可以多次声明同名变量，并且后续的声明会覆盖前面的声明。

`let`：`let` 是在 ES6 中引入的块级作用域变量声明关键字。它具有以下特点：

- 块级作用域：`let` 声明的变量的作用域是当前块内（通常是由花括号 `{}` 包围的代码块）。这意味着在块内声明的变量在块外是不可访问的。
- 没有变量提升：`let` 声明的变量不会像 `var` 那样被提升到作用域的顶部。在变量声明之前访问变量会引发错误。
- 不可重复声明：在同一个作用域内，使用 `let` 不能多次声明同名变量。在同一个作用域内，对同一个变量使用 `let` 进行重复声明会引发错误。
- 变量赋值：`let` 声明的变量可以被重新赋值，即变量的值可以改变。

`const`：`const` 是在 ES6 中引入的常量声明关键字。它具有以下特点：

- 块级作用域：`const` 声明的常量的作用域是当前块内。同样，常量在块外是不可访问的。
- 没有变量提升：`const` 声明的常量不会被提升到作用域的顶部。在常量声明之前访问常量会引发错误。
- 不可重复声明：在同一个作用域内，使用 `const` 不能多次声明同名常量。在同一个作用域内，对同一个常量使用 `const` 进行重复声明会引发错误。
- 不可变性：`const` 声明的常量的值是不可变的，一旦赋值后就不能再修改。如果尝试修改 `const` 声明的常量的值，会引发错误。

总结：

- `var` 具有函数作用域和变量提升，可以重复声明，变量的值可以修改。
- `let` 具有块级作用域，没有变量提升，不能重复声明，变量的值可以修改。
- `const` 具有块级作用域，没有变量提升，不能重复声明，常量的值不可修改。

## 5.作用域

作用域（Scope）指的是变量、函数和对象的可访问范围。作用域定义了变量和函数在代码中的可见性和生命周期。

JavaScript 中有以下几种作用域：

1. 全局作用域（Global Scope）：全局作用域是指在代码中任何位置都可访问的范围，它定义了全局变量和全局函数。在浏览器环境下，全局作用域通常是指 `window` 对象的属性和方法。
2. 函数作用域（Function Scope）：函数作用域是指在函数内部声明的变量和函数只能在函数内部访问，而在函数外部无法访问。每当创建一个函数时，都会创建一个新的函数作用域。
3. 块级作用域（Block Scope）：块级作用域是指由花括号 `{}` 包围的代码块内部声明的变量，它们只在该代码块内部可访问。在 ES6 中引入了 `let` 和 `const` 关键字，它们可以创建块级作用域。

### 7. 作用域链

作用域链（Scope Chain）是指在嵌套的作用域中，每个作用域都可以访问其外部作用域中的变量和函数。当在一个作用域中访问一个变量或函数时，如果当前作用域没有定义该变量或函数，JavaScript 引擎会沿着作用域链向上查找，直到找到该变量或函数或者到达全局作用域为止。

作用域链的构建是由函数的创建时环境（创建时作用域）决定的，它取决于函数定义的位置。当函数被创建时，会记录下它所在的作用域链，然后在函数执行时，使用这个作用域链来解析变量和函数的引用。

总结：

- 作用域是指变量和函数的可访问范围，包括全局作用域、函数作用域和块级作用域。
- 作用域链是在嵌套的作用域中，用于解析变量和函数引用的链路，它通过向上查找的方式在作用域链中查找变量和函数的定义。

## 6. class类

ES6（ECMAScript 2015）引入了Class（类）的概念，使得在JavaScript中使用面向对象编程更加简洁和直观。Class提供了一种定义对象和对象之间关系的语法糖，它基于原型继承的基础上进行了封装和扩展。

以下是关于ES6的Class类的详细讲解：

1. **类的定义**：使用`class`关键字来定义一个类，并使用大驼峰命名法为类命名。类可以包含构造函数和其他成员方法。
2. **构造函数**：类中的构造函数使用`constructor`关键字定义，用于创建和初始化类的实例。构造函数在使用`new`关键字实例化类时自动调用。
3. **成员方法**：类中的成员方法是定义在类原型上的函数。可以在类的实例上调用这些方法。
4. **类的继承**：使用`extends`关键字来实现类的继承。子类可以继承父类的属性和方法，并可以添加自己的属性和方法。
5. **super关键字**：`super`关键字用于在子类中调用父类的构造函数和方法。
6. **静态方法**：通过`static`关键字定义的方法属于类本身，而不是类的实例。可以直接通过类调用静态方法，而无需实例化类。
7. **Getter和Setter**：通过`get`和`set`关键字定义的方法用于获取和设置类的属性值。
8. 类的使用使得JavaScript的面向对象编程更加清晰和易于理解。它提供了一种类似于传统类的语法，使得定义和组织代码更加直观，并且提供了更好的封装和继承机制。

## 7. es5继承，es6继承

ES5和ES6的继承在语法和实现上有一些区别。下面是ES5和ES6继承的主要区别：

ES5继承（原型链继承）：

- 使用构造函数和原型链来实现继承。
- 通过将父类的实例赋值给子类的原型，子类可以继承父类的属性和方法。
- 使用`Object.create()`方法可以创建一个新对象，并将其原型设置为指定的对象。

```js
function ParentClass() {
  // 父类构造函数
}
ParentClass.prototype.method1 = function() {
  // 父类方法
};
function ChildClass() {
  // 子类构造函数
}
ChildClass.prototype = Object.create(ParentClass.prototype); // 继承父类原型
ChildClass.prototype.method2 = function() {
  // 子类方法
};
```

ES6继承（类继承）：

- 引入了`class`关键字来定义类和继承关系。
- 使用`extends`关键字来指定父类，并通过`super`关键字调用父类的构造函数和方法。
- 子类可以使用`constructor`方法来定义自己的构造函数。
- 子类可以直接通过`super`关键字调用父类的方法。

## 8.原型和原型链

在 JavaScript 中，每个对象都有一个原型（prototype），原型是一个包含属性和方法的对象。对象可以通过原型继承来共享属性和方法。

原型链是一种机制，用于解决对象之间的属性和方法查找。当我们访问一个对象的属性或方法时，如果该对象自身没有定义该属性或方法，JavaScript 引擎就会沿着对象的原型链向上查找，直到找到相应的属性或方法或者到达原型链的末尾（null）为止。

简而言之，所有对象都有一个原型通过`__proto__`，而该原型任然是一个对象，他也有一个`__proto__`来指向它的原型，这样一直向上，直到找到Object对象的原型，也就是null为止。而这就是一条原型链。

## 9. HTTP2.0的多路复用

### HTTP2.0的特点

- 兼容HTTP/1.1
- 头部压缩
  - 于常见的 HTTP 头部通过**静态表和 Huffman 编码**的方式，将体积压缩了近一半，而且针对后续的请求头部，还可以建立**动态表**，将体积压缩近 90%，大大提高了编码效率，同时节约了带宽资源。
  - 不过，动态表并非可以无限增大， 因为动态表是会占用内存的，动态表越大，内存也越大，容易影响服务器总体的并发能力，因此服务器需要限制 HTTP/2 连接时长或者请求次数。
- 二进制帧
- 并发传输（多路复用）
  - **HTTP/2 实现了 Stream 并发**，多个 Stream 只需复用 1 个 TCP 连接，节约了 TCP 和 TLS 握手时间，以及减少了 TCP 慢启动阶段对流量的影响。不同的 Stream ID 可以并发，即使乱序发送帧也没问题，比如发送 A 请求帧 1 -> B 请求帧 1 -> A 请求帧 2 -> B 请求帧2，但是同一个 Stream 里的帧必须严格有序。
  - 另外，可以根据资源的渲染顺序来设置 Stream 的**优先级**，从而提高用户体验。
- 服务器主动推送资源
  - **服务器支持主动推送资源**，大大提升了消息的传输性能，服务器推送资源时，会先发送 PUSH_PROMISE 帧，告诉客户端接下来在哪个 Stream 发送资源，然后用偶数号 Stream 发送资源给客户端。

## 10.token或者jwt的内容有哪些，与cookie有什么不同

令牌（Token）或JWT（JSON Web Token）和Cookie是用于在身份验证和授权过程中传递信息的不同机制，它们在内容和使用方法上有所不同。

**token和jwt的内容：**

- 令牌或JWT是一种基于JSON格式的数据结构，通常由三个部分组成：头部、荷载和签名
  - 头部：包含描述令牌的元数据和算法信息，例如令牌类型、所使用的加密算法等。
  - 荷载：包含有关用户或其它相关信息的声明，例如用户ID、角色、权限等。荷载可以自定义，以满足应用程序的需求。
  - 签名：用于验证令牌的完整和真实性的签名部分。签名使用服务器端密钥进行加密，以确保令牌在传输过程中没有被篡改。

**Cookie的内容**：

- Cookie是在客户端（通常是Web浏览器）保存的小型文本文件，由服务器发送给客户端并存储在客户端的文件系统中。
- Cookie的内容是键值对形式的数据，其中键是Cookie的名称，值是与之相关联的数据。Cookie可以包含一些元数据，如过期时间、域名、路径等。

**区别**：

1. **存储位置**：令牌或JWT通常存储在客户端的内存中，可以作为请求的一部分（在请求头或请求体中）或者存储在客户端的本地存储中（如Web Storage、LocalStorage等）。而Cookie存储在客户端的文件系统中。
2. **安全性**：令牌或JWT可以使用**签名进行验证**，以确保其完整性和真实性。**签名使用服务器端密钥进行加密**。相比之下，Cookie的内容在客户端存储，不提供完整性和真实性的验证，容易受到篡改。
3. **跨域支持**：由于令牌或JWT可以作为请求的一部分进行传递，因此它们可以轻松地在不同域之间进行传输。而Cookie在跨域请求时需要通过设置CORS（跨域资源共享）等机制来实现跨域共享。
4. **存储容量**：Cookie的存储容量受到浏览器的限制，通常为几KB到几十KB。而令牌或JWT可以根据需要包含更多信息，因此通常具有更大的存储容量。

## 11. HTTPS是用非对称加密还是对称加密

HTTPS使用了混合加密机制，其中包括了对称加密和非对称加密。

当客户端与服务器进行HTTPS通信时，以下是加密过程的简要步骤：

1. 客户端发送一个HTTPS请求给服务器。
2. 服务器将包含其公钥的数字证书发送给客户端。
3. 客户端验证证书的合法性，包括检查发行机构以及证书本身的有效期等。
4. 客户端生成一个会话密钥（对称密钥）。
5. 客户端使用服务器的公钥对会话密钥进行加密，然后将加密后的会话密钥发送给服务器。
6. 服务器使用自己的私钥对接收到的加密会话密钥进行解密，得到原始的会话密钥。
7. 服务器和客户端现在都拥有相同的会话密钥，可以使用对称加密算法（如AES）来加密和解密通信的数据。

在这个过程中，非对称加密用于安全地交换对称密钥。它提供了身份验证和密钥交换的保证，而对称加密则用于实际的数据加密和解密，因为对称加密算法更高效。

总结来说，HTTPS使用非对称加密来确保安全密钥交换，并使用对称加密来加密和解密实际的数据传输过程。

## 13. treeshaking了解过吗

树摇（Tree shaking）是指通过静态代码分析和模块依赖关系来消除 JavaScript 或 TypeScript 中未使用的代码，以减少最终打包输出的文件大小。

在现代的 JavaScript 模块打包工具（如Webpack、Rollup等）中，开发者通常使用模块化的方式编写代码，将功能拆分为多个模块。然而，由于项目规模的增长和模块之间的复杂依赖关系，可能会导致一些模块中的部分代码在最终的打包结果中并未被使用到。

树摇的核心思想是，通过静态分析代码，确定哪些代码被实际使用，然后将未使用的代码从最终打包的输出中删除，以减少文件大小。这种静态分析是在没有运行代码的情况下进行的，它基于模块之间的依赖关系和引用关系，而不是基于运行时的行为。

在进行树摇时，打包工具会从应用程序的入口点（通常是一个或多个文件）开始，递归地分析模块之间的引用关系，标记被引用的代码。然后，它会通过一系列优化策略，如静态分析、代码解析和依赖关系分析，确定未被引用的代码，并将其从最终的打包结果中剔除。

## 14. CDN

CDN，全称为内容分发网络（Content Delivery Network），是一种分布式的计算机网络解决方案。它旨在通过将内容（例如静态文件、图像、音频、视频等）分发到全球各个位置的边缘节点，以提供快速、高效且可靠的内容传输和交付服务。

CDN的工作原理如下：

1. 当用户请求访问某个网站时，DNS（域名系统）会将请求路由到最近的CDN边缘节点之一。
2. CDN边缘节点是分布在全球各个地理位置的服务器，它们存储了原始网站的一部分内容副本。
3. 如果边缘节点上存在用户请求的内容副本（缓存命中），则边缘节点会立即将该内容返回给用户，减少传输延迟。
4. 如果边缘节点上不存在用户请求的内容副本（缓存未命中），则边缘节点会从原始网站服务器上获取内容，并将其缓存到节点上，以便以后的请求可以命中缓存。
5. CDN边缘节点还可以优化传输，通过使用负载均衡、压缩、加密等技术来提高网站的性能和安全性。

CDN的主要好处包括：

1. 更快的内容传输和页面加载速度，因为内容被缓存在离用户更近的节点上。
2. 对于访问量大或分布广泛的网站，可以减轻原始服务器的负载，提高网站的可伸缩性和稳定性。
3. 提供全球范围内的高可用性，因为即使某个边缘节点出现故障，仍然可以通过其他节点访问内容。
4. 减少网络拥塞和延迟，因为请求可以从离用户更近的边缘节点获取响应。

### 为什么使用CDN能加速页面渲染

CDN链接下载的第三方库资源通常可以有利于浏览器渲染页面的加速。

当使用CDN链接下载第三方库资源时，这些资源通常会被缓存在CDN的边缘节点上。这意味着当用户访问网站时，他们可以通过离他们更近的CDN边缘节点快速下载这些资源，而不必等待从远程服务器下载。

以下是CDN链接下载第三方库资源的几个优点：

1. 加速访问速度：CDN边缘节点分布在全球各个地理位置，将资源缓存在离用户更近的节点上，可以大大减少物理距离和网络延迟，提供更快的访问速度。
2. 减轻服务器负载：由于第三方库资源可以由CDN边缘节点提供，原始服务器可以减少对这些资源的请求和传输负载，从而提高服务器的性能和可伸缩性。
3. 并行下载：浏览器通常有限制同时下载的资源数量，通过使用CDN链接下载第三方库资源，这些资源可以并行下载，与网页的其他组件同时加载，加快页面加载速度。
4. 提供高可用性：CDN通常有多个边缘节点，即使某个边缘节点出现故障，仍然可以从其他节点获取资源，保证了较高的可用性。

## 15. 当简历超过一页的时候怎么做的分页

使用了HTML5的新特性`ResizeObserver`，它是在Web标准规范中的`ResizeObserver`的接口中定义的。

`ResizeObserver` 的目的是提供一种原生的、高效的方式来监听元素尺寸的变化。在过去，开发者通常需要使用 `window.onresize` 事件或其他 DOM 监听器来检测元素尺寸的变化，但这些方法存在一些限制和性能问题。

为了解决这些问题，`ResizeObserver` 在近年的 Web 标准中被引入，并逐渐得到了现代浏览器的支持。目前，`ResizeObserver` 已经成为了一种常见的前端开发工具，在响应式设计、自适应布局以及其他需要观察元素尺寸变化的场景中得到了广泛应用。

需要注意的是，由于 `ResizeObserver` 是较新的特性，它可能并不在所有浏览器中都得到完全支持。在使用 `ResizeObserver` 时，建议先检查浏览器的兼容性，或者提供降级方案以确保在不支持该特性的浏览器上有备选的解决方案。

使用 `window.onresize` 事件来监听一个特定元素的高度变化可能会遇到以下一些问题：

1. **事件冒泡和触发频率**：`window.onresize` 事件是在窗口大小发生变化时触发的，它会冒泡到 `window` 对象。因此，当窗口大小改变时，无法直接确定是哪个元素的高度发生了变化。此外，`window.onresize` 事件可能会频繁触发，特别是在用户拖动窗口边缘进行调整时，可能会连续触发多次，这可能导致性能问题。
2. **无法直接获取元素的高度变化**：`window.onresize` 事件提供的信息是整个窗口的尺寸变化，而不是特定元素的高度变化。如果你想要获取特定元素的高度变化，需要额外的代码来获取目标元素的高度和与窗口大小的关联。
3. **性能开销**：由于 `window.onresize` 事件可能频繁触发，特别是在复杂的页面中，监听整个窗口的尺寸变化可能会导致性能开销。如果页面中有大量的元素需要监听高度变化，并且没有合适的优化策略，可能会影响页面的流畅性和性能。

为了更准确地监听特定元素的高度变化，更好的选择是使用 `ResizeObserver` 或其他专门用于观察元素尺寸变化的方法。`ResizeObserver` 提供了高效、精确的元素尺寸观察机制，并支持观察多个目标元素的尺寸变化。它是一种更适合监听元素高度变化的现代解决方案。

## 16. Git工作流

1. **集中式工作流（Centralized Workflow）**：在集中式工作流中，代码库通常只有一个中央仓库，所有开发人员都直接从中央仓库拉取代码并将更改推送回中央仓库。这种工作流程适用于小型团队或个人项目，简单直接。
2. **功能分支工作流（Feature Branch Workflow）**：在功能分支工作流中，每个功能或任务都在自己的分支上进行开发。开发人员从主分支创建一个功能分支，进行开发和测试，并在完成后将其合并回主分支。这种工作流程允许并行开发多个功能，保持主分支的稳定性。
3. **Gitflow 工作流（Gitflow Workflow）**：Gitflow 工作流是一种分支模型，它定义了多个分支用于不同的开发阶段。主要分支包括主分支（`master`）和开发分支（`develop`），以及支持功能开发的特性分支和用于发布的发布分支。这种工作流程适用于中大型团队和长期项目。
4. **拉请求工作流（Pull Request Workflow）**：拉请求工作流通常在开源项目和团队协作中使用。团队成员在自己的分支上进行开发，然后通过拉请求（Pull Request）将其更改提交给主存储库。其他团队成员可以审查代码并提供反馈，最终由项目维护者决定是否将更改合并到主分支。

## 17. Pina在你的项目起到的作用

1. 状态管理：Pinia 提供了一个集中式的状态存储机制，可以在应用程序的不同组件之间共享和访问状态。你可以定义状态、访问状态、修改状态，并通过 getter 和 action 来处理状态的逻辑。
2. 组件通信：Pinia 允许在不同的组件之间进行状态共享，从而简化了组件之间的通信。你可以在一个组件中修改状态，然后在其他组件中访问和响应状态的变化。
3. 插件扩展：Pinia 支持插件扩展，可以通过插件来扩展和定制状态管理的功能。你可以使用插件来添加中间件、实现持久化存储、处理异步操作等。
4. TypeScript 支持：Pinia 具有良好的 TypeScript 支持，可以为状态、getter、action 等提供类型推断和类型检查，提高代码的可维护性和可靠性。

## 18. 下载功能拿什么实现的

1. **使用超链接**：最简单的方法是通过创建一个超链接来触发文件下载。你可以使用 `<a>` 元素并设置 `href` 属性为文件的 URL，同时设置 `download` 属性来指示浏览器下载文件而不是在浏览器中打开它。例如：

   ```js
   <a href="path/to/file.pdf" download>下载文件</a>
   ```

2. **使用 JavaScript 和 Blob**：如果你需要在客户端动态生成文件并下载，可以使用 JavaScript 和 Blob（二进制大对象）来实现。你可以创建一个 Blob 对象，将数据写入其中，然后使用 URL.createObjectURL() 方法生成一个临时的下载链接，最后通过创建一个隐藏的 `<a>` 元素并模拟点击来触发下载。示例代码如下：

   ```js
   function downloadFile(data, fileName) {
     const blob = new Blob([data]);
     const url = URL.createObjectURL(blob);
   
     const downloadLink = document.createElement('a');
     downloadLink.href = url;
     downloadLink.download = fileName;
   
     document.body.appendChild(downloadLink);
     downloadLink.click();
     document.body.removeChild(downloadLink);
     URL.revokeObjectURL(url);
   }
   
   // 调用下载函数
   const fileData = '这是文件的内容';
   const fileName = 'example.txt';
   downloadFile(fileData, fileName);
   ```

3. **使用 XMLHttpRequest 或 Fetch API**：如果你需要从服务器下载文件，可以使用 XMLHttpRequest 或 Fetch API 发起 HTTP GET 请求，并在接收到响应后将文件保存到本地。你可以使用 `responseType` 属性设置响应类型为 `blob`，然后使用 Blob 对象的 API 来处理响应数据。以下是使用 Fetch API 的示例代码：

   ```js
   fetch('path/to/file.pdf')
     .then(response => response.blob())
     .then(blob => {
       // 处理 Blob 对象，例如保存到本地
       // ...
     })
     .catch(error => {
       // 处理错误
       console.error(error);
     });
   ```

这些方法可以根据你的具体需求和项目环境来选择。例如，如果你需要在客户端动态生成文件，第二种方法可能更适合；如果你需要从服务器下载文件，你可以选择第三种方法。

## 19.nextTick()的作用

在 Vue 3 项目中，`await nextTick()` 的作用是等待下一个 DOM 更新周期结束。

在 Vue 中，更新 DOM 是异步操作。当你修改了数据，Vue 会在下一个事件循环周期中对 DOM 进行更新。在某些情况下，你可能需要在 DOM 更新完成后执行一些操作，比如获取更新后的 DOM 元素或执行其他操作依赖于最新的 DOM 结构。

## 20.什么是BFC

BFC（块级格式化上下文）是 CSS 中的一种渲染机制，用于控制块级元素的布局和定位。BFC 是页面上一个独立的渲染区域，具有自己的布局规则，且内部的元素按照一定的规则进行排列和定位。

BFC 具有以下特性和行为：

1. **块级元素的垂直排列**：BFC 内部的块级元素在垂直方向上一个接一个地排列，即一个元素的顶部紧邻着上一个元素的底部。
2. **边距重叠的阻止**：在同一个 BFC 内部，相邻块级元素的垂直边距会发生折叠（重叠）现象，但与其他 BFC 的元素之间的边距不会发生重叠。
3. **浮动元素的包裹**：BFC 会将浮动元素包裹在其中，不会让浮动元素溢出到 BFC 之外。
4. **阻止文字环绕**：当文本或块级元素与浮动元素重叠时，BFC 会自动调整排列，避免文字环绕浮动元素。
5. **计算 BFC 高度**：BFC 会根据其内部的元素来计算自身的高度，即使其中的元素浮动或位置为绝对定位，也会参与高度的计算。

## 21.如何获取一个页面上出现次数最多的标签

```js
const dom = document.querySelectorAll('*');
// 实现一个 maxBy 方便找出出现次数最多的 HTML 标签
const maxBy = (list,fn)=>list.reduce((a,b)=>fn(a)>fn(b)?a:b);
function getFrequenttag(){
  	// 返回出现次数最多的标签
    const tags = [...dom].map(x=>x.tagName).reduce((obj,tag)=>{
        obj[tag] = (obj[tag] || 0) + 1;
        return obj;
    },{})
    //展开统计的标签出现的频次，使其变成一个数组。
    return maxBy(Object.entries(tags),tag=>tag[1])
}
console.log(getFrequenttag(dom)[0]);
```

## 22.Vite热更新原理

Vite 是一个现代化的前端构建工具，它采用了一种基于服务端模块（server-side modules）的开发模式，以实现快速的开发和热更新。下面是 Vite 热更新的简要原理：

1. 开发服务器：Vite 在开发模式下启动一个开发服务器，该服务器作为一个中间层，与浏览器和源代码进行交互。
2. 模  块解析：当浏览器请求一个模块时，开发服务器会拦截这个请求，并对请求的模块进行解析和处理。
3. 模块转换：开发服务器会将请求的模块转换为浏览器可理解的格式。Vite 使用原生的 ESM（ES Modules）来处理模块，因此不需要像传统的打包工具那样进行打包和构建操作。
4. 构建依赖图：开发服务器会构建一个模块依赖图，跟踪模块之间的依赖关系。这使得 Vite 可以在开发过程中实时更新模块，而无需重新加载整个应用程序。
5. 热模块替换（Hot Module Replacement，HMR）：一旦某个模块发生更改，开发服务器会通知浏览器更新发生变化的模块，而不是刷新整个页面。这样，浏览器可以在不影响应用程序状态的情况下，只更新变化的部分。
6. 快速刷新：如果某些更改无法进行热更新，例如修改了全局配置文件或添加了新的依赖项，开发服务器将执行“快速刷新”，即刷新整个页面以确保最新更改的生效。

总体而言，Vite的热更新原理是基于服务端模块的动态转换和实时通信机制。它通过拦截模块请求，实时转换模块，构建依赖图和热模块替换，实现了快速的开发和更新体验，提高了前端开发的效率。

## 23.Webpack和Vite的热更新有什么区别

Webpack的热更新和Vite的热更新在实现方式和性能上存在一些区别，主要原因是它们采用了不同的构建策略。

### Webpack热更新

Webpack热更新是一种在开发过程中替换、更新模块的机制。它通过在构建过程中注入一些额外的代码来实现。当某个模块发生更改时，Webpack会通知客户端进行更新，只替换发生变化的部分，而无需刷新整个页面。Webpack的热更新需要在Webpack配置中进行额外的配置和插件支持。

### Vite热更新

Vite的热更新采用了一种基于服务端模块的开发模式。它利用现代浏览器的原生ES模块支持，通过服务端动态转换和按需加载模块，实现了快速的开发和热更新。当某个模块发生更改时，Vite会通过服务端将变更的模块实时推送给浏览器，浏览器会替换相应的模块，而无需刷新整个页面。Vite的热更新不需要额外的配置和插件，它是内置在Vite中的核心特性。

### 区别和原因

1. 构建性能：Vite的热更新性能较优，因为它利用了服务端模块的动态转换和按需加载，仅更新变更的模块，不需要重新构建整个应用程序。而Webpack的热更新需要在构建过程中注入额外的代码，并重新打包和构建相关模块，相对而言，性能可能比较慢。
2. 构建方式：Vite基于服务端模块的开发模式，不需要像Webpack一样进行打包和构建，而是直接在浏览器中运行源代码。这使得Vite具有更快的启动时间和更低的开发延迟，提供了更流畅的开发体验。
3. 工具生态：Webpack是一个成熟且广泛应用的构建工具，拥有庞大的生态系统和丰富的插件支持，适用于各种复杂的构建场景。相比之下，Vite作为相对较新的工具，生态系统相对较小，但与Vue.js的集成紧密，适用于Vue项目，并提供了更简洁的开发体验。

## 24.vue-router底层是基于什么实现的

Vue Router是Vue.js官方提供的路由管理器，它可以实现单页面应用（SPA）中的路由功能。Vue Router的底层实现是基于浏览器的`history` API 或者 `hash` 模式。

当使用`history`模式时，Vue Router利用HTML5的`history` API，包括`pushState`和`replaceState`，通过操作浏览器历史记录来实现路由导航。具体来说，Vue Router通过监听浏览器的`popstate` 事件，当用户点击浏览器的后退或前进按钮时，它会捕获该事件并相应地进行路由导航。同时，Vue Router使用`pushState`或`replaceState`方法，将新的路由信息添加到浏览器历史记录中或替换当前的历史记录，从而实现路由的切换。

当使用`hash`模式时，Vue Router会使用URL的哈希（`#`）来模拟路由。在这种模式下，路由路径会被添加到URL的哈希部分，而不会触发页面的刷新。Vue Router通过监听浏览器的`hashchange`事件来检测URL的变化，并根据哈希值的变化进行相应的路由导航。

当使用`hash`模式时，Vue Router会使用URL的哈希（`#`）来模拟路由。在这种模式下，路由路径会被添加到URL的哈希部分，而不会触发页面的刷新。Vue Router通过监听浏览器的`hashchange`事件来检测URL的变化，并根据哈希值的变化进行相应的路由导航。

## 25.histry的特性

在HTML5中，"history"（历史）是一个内置的JavaScript对象，它提供了与浏览器历史记录相关的功能。通过"history"对象，你可以访问和操作用户在浏览器中访问过的页面的历史记录。

1. `history.back()`: 这个方法用于模拟用户点击浏览器的后退按钮，将用户导航到上一个访问过的页面。
2. `history.forward()`: 这个方法用于模拟用户点击浏览器的前进按钮，将用户导航到下一个访问过的页面。
3. `history.go(n)`: 这个方法用于在历史记录中向前或向后移动n个步骤。例如，`history.go(-1)`等同于`history.back()`，`history.go(1)`等同于`history.forward()`。
4. `history.length`: 这个属性返回历史记录中的页面数量。
5. `history.pushState()`: 这个方法用于向浏览器历史记录中添加新的状态。它接受三个参数：状态对象、标题（在大多数浏览器中无效）和可选的URL。**这个方法可以改变当前URL而不刷新页面**。
6. `history.replaceState()`: 这个方法用于**修改当前历史记录中的状态，而不会在历史记录中创建新的条目**。

早期浏览器的"hash"模式是一种用于实现客户端路由的约定。在早期的Web开发中，由于缺乏现代浏览器提供的`history` API，开发者需要通过利用URL的哈希部分（`#`）来模拟路由功能。

当使用"hash"模式时，URL的格式通常为`http://example.com/#/path`，其中`#/path`部分表示路由路径。而实际上，哈希部分对于浏览器来说是一个片段标识符（fragment identifier），用于定位文档内的特定位置。

通过在URL的哈希部分中设置路由路径，开发者可以通过JavaScript监听浏览器的`hashchange`事件来检测URL的变化，从而实现路由的导航和响应。当浏览器的地址栏中的哈希部分发生变化时，`hashchange`事件会被触发，开发者可以通过事件处理函数来捕获这个事件并执行相应的路由操作。

使用"hash"模式的主要优点是在早期的浏览器中具有广泛的兼容性。在那个时代，HTML5的`history` API 还没有普及，而且一些旧版本的浏览器对它的支持不完善。通过使用URL的哈希部分来模拟路由，开发者可以实现基本的前端导航功能，而无需依赖于现代浏览器提供的功能。

然而，"hash"模式也有一些缺点。首先，URL中的哈希部分对于搜索引擎爬虫来说是不可见的，这可能会对搜索引擎优化（SEO）产生影响。其次，哈希部分的变化通常不会触发服务器请求，因此对于一些需要服务器端同步的场景，"hash"模式可能不适用。
