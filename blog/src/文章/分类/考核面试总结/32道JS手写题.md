---
icon: edit
date: 2023-10-24
category:
  - 面试考核总结
tag:
  - 面试题
star: true
sticky: true
copy.disableCopy: true
---

# 手写总结，巩固你的JS基础

作为前端开发，JS是重中之重，面对面试高峰期，总结32道手写JS问题，欢迎大家补充

## 数组扁平化

数组扁平化是指将一个多维数组变为一个一维数组

```js
const arr = [[2,3,4,5],1,3,4[[1,3,6],1,6],8,9]
// arr = [2,3,4,5,1,3,4,1,3,6,1,6,8,9]
```

### 方法一：使用flat()

```js
const res = arr.flat(Infinity);
```

### 方法二：利用正则

```js
const res = JSON.stringfy(arr).replace(/\[|\]/g,'').split(',')
```

但数据类型都会变成字符串

### 方法三：正则改良版本

```js
const res = JSON.parse('[' + JSON.stringyf(arr).replace(/\[\]/g,'') + ']');
```

### 方法四：使用reduce

```js
const flatten = arr => {
    return arr.reduce((pre,cur) => {
		return pre.concat(Array.isArray(cur) ? flatten(cur) : cur);
    },[])
}
```

### 方法五：函数递归

```js
const res = [];
const fn = arr => {
    for(let i=0;i<arr.length;i++){
        if(Array.isArray(arr[i])){
			fn(arr[i]);
        }else{
            res.push(arr[i]);
        }
    }
}
fn(arr);
```

## 限制并发数

```js
function pMap(list, mapper, concurrency = Infinity) {
    // list 为 Iterator，先转化为 Array
    list = Array.from(list)
    return new Promise((resolve, reject) => {
        let currentIndex = 0
        //收集结果的数组
        let result = []
        let resolveCount = 0
        let len = list.length
        function next() {
            const index = currentIndex
            currentIndex++
            Promise.resolve(list[index]).then(o => mapper(o, index)).then(o => {
                result[index] = o
                resolveCount++
                if (resolveCount === len) { resolve(result) }
                if (currentIndex < len) { next() }
            })
        }
        for (let i = 0; i < concurrency && i < len; i ++) {
            next()
        }
    })
}
```

## call,apply,bind函数的实现

## call函数的实现

```JavaScript
Function.prototype.myCall = function (context) {
    if (typeof this !== 'function') {
        throw new Error('应该是一个函数')
    }
    if (context === null) {
        context = window
    } else {
        context = Object(context)
        let fn = Symbol('fn')
        context[fn] = this
        let args = Array.from(arguments).slice(1)
        let result = context[fn](...args)
        Reflect.deleteProperty(context, fn)
        return result
    }
}
```

## apply函数的实现

```JavaScript
Function.prototype.myApply = function (context, args) {
    if (typeof this !== 'function') {
        throw new Error('应该是一个函数')
    }
    if (context === null) {
        context = window
    } else {
        context = Object(context)
        let fn = Symbol('fn')
        context[fn] = this
        if (Array.isArray(args)) {
            let result = context[fn](...args)
            Reflect.deleteProperty(context, fn)
            return result
        }
    }
}
```

## bind函数的实现

```JavaScript
Function.prototype.myBind = function (context) {
    if (typeof this !== 'function') {
        throw new Error('应该是一个函数')
    }
    if (context === null) {
        context = window
    } else {
        context = Object(context)
        let fn = Symbol('fn')
        context[fn] = this
        let args = Array.from(arguments).slice(1)
        let bind = function (...moreArgs) {
            let result = context[fn](...args, ...moreArgs)
            Reflect.deleteProperty(context, fn)
            return result
        }
        return bind
    }
}
```

## new操作符

```JavaScript
   function myNew (Fn,...args) {
        //创建一个新对象
        const obj = { } 
        //新对象的原型指向构造函数的原型对象
        obj.__proro__ = Fn.prototype 
        // 或者 Object.setPrototypeOf(obj, Fn.prototype)
        //改变this指向
        const result = Fn.call(obj,...args)
        //返回值
         return result instanceof Object ? result :obj 
    }
```

## instanceof

```JavaScript
function Instanceof(left, right) {
    let proto = Object.getPrototypeOf(left)
    let constructor = right.prototype
    while (proto) {
      if (proto === constructor) {
        return true
      }
      proto = Object.getPrototypeOf(proto)
    }
    return false
  }
```

手写类型判断函数

```JavaScript
function getType(value){
    if(value === null){
    //使用+的方式，将其转换为字符串
        return value+""
    }
    if(typeof value === 'object'){
        let valueClass = Object.prototype.toString.call(value)
        let type = valueClass.split(" ")[1].split("")
        type.pop()
        return type.join("").toLowerCase()
    }else{
        return typeof value
    }
}
```

## Object.assign()

```JavaScript
Object.myAssign = function(target,...source){
    if(target == null){
        throw new Error(error)
    }
    let ret = Object(target)
    source.forEach((obj)=>{
       if(obj !== null){
        for(let key in obj){
            if(obj.hasOwnProperty(key)){
                ret[key] = obj[key]
            }
        }
       }
    })
    return ret
}
```

## Object.freeze()

```JavaScript
function myFreeze(obj){
    if(typeof obj !== 'object' || obj === null){
        throw new Error(`${obj} is not a object`)
    }
    
    const keys = Object.getOwnPropertyNames(obj);
    const symbols = Object.getOwnPropertySymbols(obj);
    
    [...keys,...symbols].forEach(key => {
        Object.defineProperty(obj,key, {
            configurable: false,
            writable: false
        })
    })
    
    Object.seal(obj)
    return obj
}
```

## Promise

### 手写Promise

```JavaScript
  const PENDING = "pending"
  const RESOLVED = "resolved"
  const REJECTED = "rejected"
  function MyPromise(fn) {
    //console.log(fn)
    //保存初始化的状态
    var self = this
    //console.log(this)//MyPromise{}里面有state保存着状态
    //初始化状态
    this.state = PENDING
    //用于保存resolve或者rejected传入的值
    this.value = null
    //用于保存reslove的回调函数
    this.resolvedCallbacks = []
    //用于保存reject的回调函数
    this.rejectedCallbacks = []
    //状态变为resolved方法
    function resolve(value) {
      //判断传入的值是否是Promise对象，如果是，则状态必须等待前一个状态改变完后在进行改变
      if (value instanceof MyPromise) {
        return value.then(resolve, reject)
      }
      setTimeout(() => {
        if (self.state === PENDING) {
          self.state = RESOLVED
          self.value = value
          self.resolvedCallbacks.forEach(callback => {
            callback(value)
          })
        }
      }, 0)
    }
    //状态转变为rejected方法
    function reject(value) {
    if (value instanceof MyPromise) {
        return value.then(resolve, reject)
      }
      setTimeout(() => {
        if (self.state === PENDING) {
          self.state = REJECTED
          self.value = value
          self.rejectedCallbacks.forEach(callback => {
            callback(value)
          })
        }
      }, 0)
    }
    //用于调用fn函数并处理执行异步操作的回调函数 fn 可能抛出的异常
    try {
      fn(resolve, reject)
    } catch (error) {
      reject(error)
    }
  }
  //then如果传入的不是函数的话就会被忽略
  //then 方法对于非函数类型的参数会进行处理，将其视为默认的回调函数
  MyPromise.prototype.then = function (onResolved, onRejected) {
    onResolved = typeof onResolved === 'function' ? onResolved : function (value) { return value }
    onRejected = typeof onRejected === 'function' ? onRejected : function (value) { return value }
    //如果是等待状态，则将函数添加到对应的状态序列中
    if (this.state === PENDING) {
      this.resolvedCallbacks.push(onResolved)
      this.rejectedCallbacks.push(onRejected)
    }
    //如果状态已凝固，则直接执行对应状态的函数
    if (this.state === RESOLVED) {
      onResloved(this.value)
    }
    if (this.state === REJECTED) {
      onRejected(this.value)
    }
  }
  // 使用手写 Promise
  const promise = new MyPromise((resolve, reject) => {
    setTimeout(() => {
      const randomNum = Math.random();
      if (randomNum < 0.5) {
        resolve("chenggong ");
      } else {
        reject(new Error('Number is greater than 0.5'));
      }
    }, 1000);

  });

  promise.then(
    value => {
      console.log('Resolved:', value);
    },
    error => {
      console.log('Rejected:', error.message);
    }
  );
```

### 手写Promise.then

```JavaScript
function Mythen(onResolved, onRejected) {
    return new Promise((resolve, reject) => {
        let resolved = () => {
            setTimeout(()=>{
                try {
                    const result = onResolved(this.value)
                    return result = result instanceof MyPromise ? result.then(resolve, reject) : resolve(result)
                } catch (error) { 
                    reject(error) 
                }
            })
        }
        let rejected = () => {
            setTimeout(()=>{
                try {
                    let result = onRejected(this.reason)
                    return result = result instanceof MyPromise ? result.then(resolve, reject) : reject(result)
                } catch (error) {
                    reject(error)
                }
            })
        }
        if (this.state === PENDING) {
            this.resolveCallbacks.push(resolved)
            this.rejectCallbacks.push(rejected)
        } else if (this.state === RESOLVED) {
            resolved()
        } else if (this.state === REJECTED) {
            rejected()
        }
    })
```

### Promise.all

```JavaScript
// 调用all方法
Promise.myAll = function(proms){
    //返回一个all方法
    return new Promise((res,rej)=>{
        let arr = [];
        //count用来记录all()参数的个数
        let count = 0;
        //fullCount用来记录参数内promise被兑现成功执行的个数，以此作为结束的条件
        let fullCount = 0;
        // for ... of 遍历数组内的所有值（必须用forof，它是所有可迭代对象都可以使用的循环方法）
        for (const item of proms) {
            //保存当前下标，利用闭包保证all()方法内的值的peomirse值按顺序存入arr结果数组
            const i = count;
            count++;
            // then方法放入微任务队列，等待循环全部执行完毕开始执行微任务队列的内容。
            Promise.resolve(item).then(r=>{
                arr[i] = r;
                //用来判断是否所有promise都执行完成
                fullCount++;
                //如果所有promise都执行完成，则执行res方法，将结果数组返回
                if(fullCount === count) {
                    res(arr);
                }
            },rej)
        }
        if(count === 0) res(arr);  
    })
}
```

### Promise.race

```JavaScript
function promiseRace(promises){
    if(!Array.isArray(promises)){
        throw new Error('应该传入一个数组')
    }
    return new Promise((resolve,reject)=>{
        for(let i=0;i<promises.length;i++){
            promises.resolve(promises[i])
            .then(value=>{
              resolve(value)
            })
            .catch(error=>{
                reject(error)
            })
        }
    })
}
```

## sleep()函数

```JavaScript
function sleep(delay){
  return new Promise(resolve=>{
    setTimeout(resolve,delay)
  })
}
async function example(){
  console.log('Before sleep')
  await sleep(2000)//暂停两秒执行后面的代码
  console.log('After sleep')
}
example()
```

## 数组API

### flat():

**用于将嵌套数组扁平化为一个新的****一维数组****,接受两个参数，第一个参数是要扁平的数组，第二个参数是扁平的层数，通过将depth设置为Infinity可以实现完全扁平化**

```JavaScript
function MyFlat(arr,depth){
  if(!Array.isArray(arr)||depth<=0){
     return arr
  }
  return arr.reduce((prev,cur)=>{
     if(Array.isArray(cur)){
     //递归实现
        return prev.concat(MyFlat(cur,depth))
     }else{
        return prev.concat(cur)
     }
  },[])
}
```

### push():

**向数组的末尾添加一个或多个元素，会修改元素组，返回修改后的长度**

```JavaScript
let arr = []
Array.prototype.push = function(){
  for(let i=0;i<arguments.length;i++){
     this[this.length] = arguments[i]
  }
  return this.length
}
```

### filter():

**返回一个新数组****，根据指定的条件选出符合条件的元素，接受一个****回调函数****，接收三个参数，当前元素的值，当前元素的索引，整个数组本身**

```JavaScript
Array.prototype.filter = function(fn){
  if(typeof fn !== 'function'){
    console.log('参数必须是一个函数')
}
  let res = []
  for(let i=0;i<this.length;i++){
  //判断是否符合条件，符合则放入res数组中
    fn(this[i]) && res.push(this[i])
  }
  return res
}
```

### map():

**返回一个新数组****，接受一个****回调函数****作为参数，用于对数组的每个元素执行指定的操作**

```JavaScript
Array.prototype.map = function(fn){
  if(typeof fn !== 'function'){
    console.log('参数应该是一个函数')
  }
  let res = []
  for(let i=0;i<this.length;i++){
  //fn(this[i]):对每个元素执行回调函数
     res.push(fn(this[i]))
  }
  return res
}
```

### forEach():

**参数是一个****回调函数****，并对数组中的每个元素执行指定的回调函数，回调函数接受三个参数：当前元素的值，当前元素的索引，整个数组本身。仅用于遍历数组并对每个元素进行操作，****并不会返回新数组。**

```JavaScript
Array.prototype.myForEach = function(fn){
   if(typeof fn !== 'function'){
      throw Error
   }
   let _this = arguments[0]||window
   for(let i = 0;i<this.length;i++){
      fn.call(_this,this[i],i,this)
   }
}
let numbers = [1,2,3,4,5]
let arr = []
numbers.myForEach(function(number){
  arr.push(number*2)
})
console.log(arr)//[2,4,6,8,10]
```

### some():

**用于判断数组中是否至少有一个元素满足条件，如果满足则返回true,否则返回false,接受一个****回调函数****作为参数，回调函数接收三个参数，当前元素的值，当前元素的索引和整个数组本身**

```JavaScript
Array.prototype.mySome = function(callback){
  if(typeof callback !== 'function'){
    throw Error
  }
  for(let i=0;i<this.length;i++){
    if(callback(arr[i],i,this)){
       return true
    }
  }
  return false
}
```

### reduce():

**用于对数组中的元素进行累加计算，并返回最终的结果，接受两个参数，一个是****回调函数****，一个是可选的初始值，回调函数接受四个参数：****累加器****(即上一次回调函数返回的初始值)，当前元素，当前索引和整个数组**

```JavaScript
Array.prototype.myReduce = function(callback,prev){
   if(typeof callback !== 'function'){
      throw Error
   }
   //是否传入prev会影响遍历数组时的开始索引，如果传入了初始值，则索引从0,开始，如果没传入，则索引从1开始
   let initialValue = prev === undefined?1:0
   prev = prev===undefined?this[0]:prev
   for(let i = initialValue;i<this.length;i++){
     prev = callback(prev,this[i],i,this)
   }
   return prev
}
//使用示例：
let arr = [1,2,3,4,5]
  let sum = arr.myReduce(function(prev,cur){
    return prev+cur
  },0)
  console.log(sum)//15
```

## 防抖：

**多次触发，只执行最后一次，如果在指定的时间内再触发某事件，就会重新计时。**

```JavaScript
function debounce(func,delay){
//将timer设置为null,只是释放了对它的引用，但定时器还存在
  let timer = null;
  return function(...args){
  //清空计时器
     clearTimeout(timer)
     timer = setTimeout(()=>{
        func.apply(this,args)
     },delay)
  }
}
//使用示例
// 假设有一个处理输入框输入事件的函数
function handleInput(value) {
  console.log(value);
}

// 创建防抖函数
const debouncedHandleInput = debounce(handleInput, 500);

// 模拟输入事件
debouncedHandleInput('First input');  // 这次触发会被延迟执行
debouncedHandleInput('Second input'); // 在延迟时间内再次触发，会重新计时
// 在延迟时间内没有再次触发，函数会被执行
```

## 节流

  规定时间内只会有一次事件执行，在这个规定时间内，如果有新的事件触发不执行

```JavaScript
function throttle(fn, delay) {
    let curtime = 0
    return function (...args) {
        let nowtime = Date.now()
        if (nowtime - curtime >= delay) {
            fn.apply(this, args)
            curtime = nowtime
        }
    }
}
//使用
// 假设有一个处理滚动事件的函数
function handleScroll() {
  console.log('Scrolling...');
}

// 创建节流函数
const throttledHandleScroll = throttle(handleScroll, 300);

// 监听滚动事件，并应用节流函数
window.addEventListener('scroll', throttledHandleScroll);
```

## 管道函数

管道函数：将多个函数连接起来形成一个管道，将前一个函数的输出作为下一个函数的输入

管道函数的数据流是从左到右的单向流动，这种数据流的顺序和方向都是固定的，每个函数在管道中的位置决定了他们在数据流中的执行顺序。

```JavaScript
    //...fns接受任意数量的参数作为函数，并将它们放到一个fns数组中
    function pipe(...fns){
        return function(x){
            return fns.reduce((prev,cur)=>{
                return cur(prev)
            },x)
        }
    }
    //使用实例：
    function addTwo(x) {
  return x + 2;
}

function multiplyByThree(x) {
  return x * 3;
}

function subtractTen(x) {
  return x - 10;
}

const pipeline = pipe(addTwo, multiplyByThree, subtractTen);
const result = pipeline(5);
console.log(result); // 输出: 11
```

## 函数柯里化

函数柯里化：一种将接受多个参数的函数转换为一系列只接受一个参数的函数的方法

```JavaScript
function curry(fn,args){
    args = args || []
    console.log(args)
    return function(){
        let Args = args.slice(0)
        console.log(Args)
        for(let i=0;i<arguments.length;i++){
           Args.push(arguments[i])
        }
        if(Args.length>=fn.length){
           return fn.apply(this,Args)
        }else{
            return curry.call(this,fn,Args)
        }
    }
}
```

## 解析URL参数

```JavaScript
function parseURLParams(url) {
  const params = {};
  const queryString = url.split('?')[1];

  if (queryString) {
    const paramPairs = queryString.split('&');
    for (let i = 0; i < paramPairs.length; i++) {
      const pair = paramPairs[i].split('=');
      const key = decodeURIComponent(pair[0]);
      const value = decodeURIComponent(pair[1] || '');
      if (key) {
        if (params[key]) {
          if (Array.isArray(params[key])) {
            params[key].push(value);
          } else {
            params[key] = [params[key], value];
          }
        } else {
          params[key] = value;
        }
      }
    }
  }

  return params;
}
```

## **浅拷贝**

```JavaScript
  function shallowCopy(object){
    if(!object || typeof object !== 'object')return;
    let newObject = Array.isArray(object) ? []:{}
    for(let key in object){
        if(object.hasOwnProperty(key)){
            newObject[key]=object[key]
        }
    }
    return newObject
}
let obj = {a:1,b:2}
let obj1 = shallowCopy(obj)
console.log(obj1)//{a:1,b:2}
```

## 深克隆

深克隆主要针对对象进行克隆，会创建一个新的对象，将目标对象的属性和方法复制到新对象中，保证了在修改一个对象时不会影响另一个对象。

```JavaScript
//使用clone = new Map():map中的存储是不重复的
function deepClone(target, clone = new Map()) {
  // 如果目标对象存在，则直接返回，避免重复克隆
  if (clone.has(target)) {
    return clone.get(target);
  }
  if (target instanceof Object) {
    let dist;
    if (target instanceof Array) {
      dist = [];
    } else if (target instanceof Function) {
       dist = function () {
        return target.call(this, ...arguments);
      };
    } else if (target instanceof RegExp) {
      dist = new RegExp(target.source, target.flags);
    } else if (target instanceof Date) {
      dist = new Date(target);
    } else {
      dist = {};
    }
    // 该遍历主要针对对象和数组
    for (let key in target) {
      if (target.hasOwnProperty(key)) {
        dist[key] = deepClone(target[key], clone);
      }
    }
    // 将所创建的放入map中，防止下次重复克隆
    clone.set(target, dist);
    return dist;
  } else {
    return target;
  }
}
```

## 上拉加载

```JavaScript
//浏览器高度
let clientHeight  = document.documentElement.clientHeight; 
//body总长度
let scrollHeight = document.body.scrollHeight;
 //距离视窗还用50的时候，开始触发；
let scrollTop = document.documentElement.scrollTop;
let distance = 50; 
if ((scrollTop + clientHeight) >= (scrollHeight - distance)) {
    console.log("开始加载数据");
}
```

## 下拉刷新

```JavaScript
<div>
    <p class="refreshText"></p>
    <ul id="refreshContainer">
        <li>111</li>
        <li>222</li>
        <li>333</li>
        <li>444</li>
        <li>555</li>

    </ul>
</div>
const refreshContainer = document.getElementById('refreshContainer')
// 监听初始位置 
refreshContainer.addEventListener('touchstart', function (e) {
      startPos = e.touches[0].pageY // 记录初始位置
      //设置刷新容器的样式，来实现一个平滑的效果
      refreshContainer.style.position = 'relative'
      refreshContainer.style.transition = 'transform 0s'
  }, false)
//记录差值，通过计算当前位置与初始位置之间的差值，根据差值的大小来改变刷新文本的内容和刷新容器的位置
 refreshContainer.addEventListener('touchmove', function (e) {
    // e.touches[0].pageY 当前位置
 transitionHeight = e.touches[0].pageY - startPos // 记录差值

    if (transitionHeight > 0 && transitionHeight < 60) {
      refreshText.innerText = '下拉刷新'
     refreshContainer.style.transform = 'translateY(' + transitionHeight + 'px)'

        if (transitionHeight > 55) {
            refreshText.innerText = '释放更新'
        }
    }
}, false)
// 监听 touchend 方法 ，设置过渡效果的样式，将刷新容器恢复到原始位置，并修改刷新文本的内容为'更新中'
 refreshContainer.addEventListener('touchend', function (e) {
    refreshContainer.style.transition = 'transform 0.5s ease 1s'
    refreshContainer.style.transform = 'translateY(0px)'
    refreshText.innerText = '更新中...'
    setTimeout(() => {
        refreshText.innerText = ''
    }, 1000)
    // todo...

}, false);
```

## 使用promise封装ajax

```JavaScript
  function getURL(url) {
    let promise = new Promise((resolve, reject) => {
      let xhr = new XMLHttpRequest()
      xhr.open('CET', url)
      xhr.onreadyStatechange = function () {
        if (this.readyState === 4) {
          if (this.status === 200) {
            resolve(this.response)
          } else {
            reject(this.statusText)
          }
        }
        xhr.onerror = function () {
          reject(this.statusText)
        }
      }
      //设置响应数据的类型
      xhr.responseType = "json"
      //设置请求头信息
      xhr.setRequestHeader()
      xhr.send()
    })
    return promise
  }
```

## 使用setTimeout模拟setInterval

setInterval是指每过一段时间将该函数执行一次，但执行并不是说立即就执行该函数，他真正的作用是每隔一段时间将事件加入到事件队列中去，只有当前的执行栈为空时，才能去事件队列中取出事件执行。但是当执行栈需要执行很长时间时，就会导致事件队列中积累多个定时器，当执行栈结束的时候这些事件会依次执行，因此就不能达到间隔一段时间执行的效果。

```JavaScript
function mySetInterval(callback, delay) {
  function interval() {
    callback();
    setTimeout(interval, delay);
  }
  setTimeout(interval, delay);
}

// 使用示例
function myCallback() {
  console.log("This is my custom setInterval function!");
}

// 每隔 1 秒执行一次回调函数
mySetInterval(myCallback, 1000);
```

## 树与数组的相互转换

### 数组转树：

```JavaScript
//arr:当前要转换为树的数组，parentId:当前节点的父节点
function arrayToTree(arr, parentId) {
    let tree = []
    for (let i = 0; i < arr.length; i++) {
        //如果两者相等，表示当前节点是parentId的子节点
        if (arr[i].id === parentId) {
            let children = arrayToTree(arr, arr[i].id)
            if (children.length > 0) {
                arr[i].children = children
            }
            tree.push(arr[i])
        }
    }
    return tree
}
//使用实例：
let data = [
  { id: 1, parentId: null, name: 'A' },
  { id: 2, parentId: 1, name: 'B' },
  { id: 3, parentId: 1, name: 'C' },
  { id: 4, parentId: 2, name: 'D' },
  { id: 5, parentId: 2, name: 'E' },
  { id: 6, parentId: 3, name: 'F' },
  { id: 7, parentId: 3, name: 'G' },
];

let tree = arrayToTree(data, null);
console.log(tree);
//转换结果：
[
  {
    id: 1,
    parentId: null,
    name: 'A',
    children: [
      {
        id: 2,
        parentId: 1,
        name: 'B',
        children: [
          { id: 4, parentId: 2, name: 'D', children: [] },
          { id: 5, parentId: 2, name: 'E', children: [] }
        ]
      },
      {
        id: 3,
        parentId: 1,
        name: 'C',
        children: [
          { id: 6, parentId: 3, name: 'F', children: [] },
          { id: 7, parentId: 3, name: 'G', children: [] }
        ]
      }
    ]
  }
]
```

### 树转数组：

```JavaScript
function treeToArray(tree) {
  let arr = [];
  for (let i = 0; i < tree.length; i++) {
    arr.push(tree[i]);
    if (tree[i].children && tree[i].children.length > 0) {
      let children = tree[i].children;
      delete tree[i].children;
      arr = arr.concat(treeToArray(children));
    }
  }
  
  return arr;
}
//使用实例：
//树
let tree = [
  {
    id: 1,
    name: 'A',
    children: [
      { id: 2, name: 'B', children: [{ id: 4, name: 'D', children: [] }, { id: 5, name: 'E', children: [] }] },
      { id: 3, name: 'C', children: [{ id: 6, name: 'F', children: [] }, { id: 7, name: 'G', children: [] }] },
    ],
  },
];

let arr = treeToArray(tree);
console.log(arr);
//转换后的结果
[
  { id: 1, name: 'A' },
  { id: 2, name: 'B' },
  { id: 4, name: 'D' },
  { id: 5, name: 'E' },
  { id: 3, name: 'C' },
  { id: 6, name: 'F' },
  { id: 7, name: 'G' }
]
```

## 数组拍平

### 递归实现

```JavaScript
//无层数要求
function flatten(arr){
  let result = []
  for(let i = 0;i<arr.length;i++){
    if(Array.isArray(arr[i])){
       result = result.concat(flatten(arr[i]))
    }else{
       result.push(arr[i])
    }
  }
  return result
}

//有层数要求
function myFlat(arr,nums = Infinity){
    let res = []
    
    for(const item of arr){
        if(nums > 0 && Array.isArray(item)){
            nums--;
            res = res.concat(myFlat(item,nums))
        }else{
            res.push(item)
        }
    }
    
    return res
} 
```

### reduce+递归

```JavaScript
//无层数要求
function flatten(arr){
    return arr.reduce((prev,cur)=>{
      return prev.concat(Array.isArray(cur) ? flatten(cur) : cur)
    },[])
}

//有层数要求
function myFlat (arr, nums = Infinity) {
    return arr.reduce((prev, cur) => {
        if (nums > 0 && Array.isArray(cur)) {
            return prev.concat(myFlat(cur, nums-1))
        } else {
            return prev.concat([cur])
        }
    }, [])
}
```

### 使用some和扩展运算符

```JavaScript
function flat(arr) {
    let res = []
    arr.some(item => {
        if (Array.isArray(item)) {
            res = res.concat(...item)
        } else {
            res.push(item)
        }
    })
    return res
}
```

###  flat

```JavaScript
let arr = [1,2,[3,4,5]]
function flat(arr){
  return arr.flat(Infinity)
}
```

### while + some

```JavaScript
function myFlat(arr,nums = Infinity) {
    while(nums > 0 && arr.some((item) => Array.isArray(item))){
        nums--;
        arr=[].concat(...arr)
    }
    return arr
}
```

## 数组去重

### set

```JavaScript
const arr = [1,5,3,8,1,3,9]
Array.from(new Set(arr))
```

###  使用map：

```JavaScript
function uniqueArray(arr) {
    let res = []
    let map = {}
    for (let i = 0; i < arr.length; i++) {
        if (!map.hasOwnProperty(arr[i])) {
            map[arr[i]] = 1;
            res.push(arr[i])
        }
    }
    return res
}
```

### 使用双重for循环去重

```JavaScript
function unique(arr){
    for(let i=0;i<arr.length;i++){
        for(let j =i+1;j<arr.length;j++){
            if(arr[i]===arr[j]){
                arr.splice(i,1)
                j--
            }
        }
    }
    return arr
}
```

### 使用indexOf():数组或字符串的一种方法，返回第一个匹配元素的索引

```JavaScript
function unique(arr){
  let res = []
  for(let i=0;i<arr.length;i++){
    if(res.indexOf(arr[i])=== -1){
       res.push(arr[i])
    }
  }
}
```

### reduce + includes

```JavaScript
function unique(arr){
  return arr.reduce((prev,cur)=>{
     return prev.includes(cur)?prev:[...prev,cur]
  },[])
}
```

### includes

```JavaScript
function unique(arr){
  let res = []
  for(let i = 0;i<arr.length;i++){
    if(!res.includes(arr[i])){
       res.push(arr[i])
    }
  }
  return res
}
```

### sort

```JavaScript
function unique(arr) {
    arr.sort((a, b) => a - b)
    const res = [arr[0]]
    for (let i = 1; i < arr.length; i++) {
        if (arr[i] !== arr[i - 1]) {
            res.push(arr[i])
        }
    }
    return res
}
```

### 使用filter和indexOf

```JavaScript
function unique (arr) {
    return arr.filter((item,index,arr)=>{
        arr.indexOf(item) === index
    })
}
```

## 虚拟DOM与真实DOM之间的转换

### 虚拟DOM转真实DOM：

```JavaScript
function createRealDOM(virtualDOM){
    let element = document.createElement(virtualDOM.tagName)
    for(let propName in virtualDOM.props){
        element.setAttribute(propName,virtualDOM.props[propName])
    }
    for(let child of virtualDOM.children){
        if(typeof child === 'string'){
            element.appendChild(document.createTextNode(child))
        }else{
            const childElement = createRealDOM(child)
            element.appendChild(childElement)
        }
    }
    return element
}
```

### 真实DOM转虚拟DOM：

```JavaScript
function createVirtualDOM(realDOM) {
  let tagName = realDOM.tagName;
  let props = {};
  for (let attr of realDOM.attributes) {
    props[attr.nodeName] = attr.nodeValue; 
  }
  let children = [];
  for (let child of realDOM.childNodes) {
    if (child.nodeType === Node.TEXT_NODE) {
      children.push(child.textContent);
    } else if (child.nodeType === Node.ELEMENT_NODE) {
      children.push(createVirtualDOM(child));
    }
  }
  const virtualDOM = {
    tagName,
    props,
    children
  };
  return virtualDOM;
}
```

## 消息订阅与发布

```JavaScript
  class EventCenter {
        constructor() {
        //事件管理器：存储所有事件
            this.event = {}
        }
        //订阅
        //type:事件名，handler:事件方法
        subscribe(type, handler) {
            if (!this.event[type]) {
                this.event[type] = []
            }
            this.event[type].push(handler)
        }
        //发布
        publish(type, ...data) {
            if (!this.event[type]) {
                throw new Error('该事件未注册')
            }
            //遍历所有事件，找到handler,传入参数执行回调函数
            this.event[type].forEach(handler => {
                handler(...data)
            })
        }
        //取消订阅
        unsubscribe(type, handler) {
            if (!this.event[type]) {
                throw new Error('不存在该事件')
            }
            //如果没传第二个参数，则会删除该事件整体
            if (!handler) {
                delete this.event[type]
            } else {
            //indexOf未找到则返回-1
                const index = this.event[type].indexOf(handler)
                if (index === -1) {
                    throw new Error('无绑定该事件')
                }
                //splice(index,1):删除index这一个元素
                this.event[type].splice(index, 1)
                //如果type事件中只有一个handler方法
                if (this.evnet[type].length === 0) {
                    delete this.event[type]
                }
            }
        }
    }
```

## 最大数量并发

```JavaScript
//创建一个类，max代表最大并发数量
class MaxConcurrency {
  constructor(max) {
    this.max = max;
    //正在运行的程序的个数
    this.running = 0;
    //任务队列
    this.queue = [];
  }

  execute(fn) {
    if (this.running < this.max) {
      this.running++;
      fn().then(() => {
        this.running--;
        this.next();
      });
    } else {
      this.queue.push(fn);
    }
  }
  next() {
    if (this.running < this.max && this.queue.length > 0) {
      this.running++;
      //shift:删除数组的第一个元素并返回该元素
      const fn = this.queue.shift();
      fn().then(() => {
        this.running--;
        this.next();
      });
    }
  }
}
const maxConcurrency = new MaxConcurrency(2);

function asyncTask() {
  return new Promise(resolve => {
    setTimeout(() => {
      console.log('Async task completed.');
      resolve();
    }, 1000);
  });
}

maxConcurrency.execute(asyncTask);
maxConcurrency.execute(asyncTask);
maxConcurrency.execute(asyncTask);
maxConcurrency.execute(asyncTask);
//先输出两个Async task completed.过两秒后再输出两个，因为最大并发数量是2
function multiRequestLimitNum(urlsArr, limitNum){
    const len = urlsArr.length; //请求总数量
    const res = new Array(len).fill(0)//请求结果
    let sendCount = 0//已发送的请求数量
    let finishCount = 0//已完成的请求数量
    return new Promise((resolve,reject)=>{
        //首先发送limitNum个请求，注意：请求数可能小于 limitNum，所以也要满足条件2
        //同步的 创建limitNum个next并行请求 然后才去执行异步的fetch 所以一上来就有5个next并行执行
        while(sendCount < limitNum && sendCount < len){
            next()
        }
        function next(){
            let current = sendCount++ //当前发送的请求数量，保存当前请求url的位置
            // 递归出口
            if(finishCount >= len){
            // 如果所有请求完成，则解决掉 Promise，终止递归
                resolve(res)
                return
            }
            const url = urlsArr[current]
            fetch(url).then(result => {
                finishCount++
                res[current] = result
                if(current < len){// 如果请求没有发送完，继续发送请求
                    next()
                }
            },err => {
                finishCount++
                res[current] = err
                if (current < len) { // 如果请求没有发送完，继续发送请求
                    next()
                }
            }
        }
    })
}
```

## 组合函数

组合函数：有两种方式：函数柯里化和函数合成，将上一个函数的输出作为下一个函数的输入

组合函数的数据流是不固定的，他的数据流是根据具体的组合方式和函数之间的关系来确定的，相比于管道函数，组合函数更加灵活，可以在任意方向上组合和调用

```JavaScript
function compose(...fns){   
    console.log(fns);
    return function(x){
        return fns.reduceRight((prev,cur)=>{
            return cur(prev)
        },x)
    }
}
//使用示例：
const addOne = (x) => x + 1;
const double = (x) => x * 2;
const square = (x) => x * x;

const composed = compose(square,double,addOne)
const result = composed(3)
console.log(result)//19
```

## 管道函数

```JavaScript
function compose(...fns){   
    console.log(fns);
    return function(x){
        return fns.reduceRight((prev,cur)=>{
            return cur(prev)
        },x)
    }
}
//使用示例：
const addOne = (x) => x + 1;
const double = (x) => x * 2;
const square = (x) => x * x;

const composed = compose(square,double,addOne)
const result = composed(3)
console.log(result)//19
```

## 红绿灯

### promise实现

```JavaScript
const task = (timer, light) => {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            if (light === 'red') {
                red()
            } else if (light === 'green') {
                green()
            } else if (light === 'yellow') {
                yellow()
            }
            resolve()
        }, timer)
    })
}
const step = () => {
    task(3000, 'red')
        .then(() => task(2000, 'yellow'))
        .then(() => task(1000, 'green'))
        .then(step)
}
const red = () => {
    console.log('red')
}
const green = () => {
    console.log('green')
}
const yellow = () => {
    console.log('yellow')
}
step()
```

async/await

```JavaScript
const task = (timer, light) => {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            if (light === 'red') {
                red()
            } else if (light === 'green') {
                green()
            } else if (light === 'yellow') {
                yellow()
            }
            resolve()
        }, timer)
    })
}
const red = () => {
    console.log('red')
}
const green = () => {
    console.log('green')
}
const yellow = () => {
    console.log('yellow')
}
const taskRunner = async () => {
    await task(3000, 'red')
    await task(2000, 'green')
    await task(1000, 'yellow')
    taskRunner()
}
taskRunner()
```

### 循环打印

```JavaScript
function trafficLights(){
    const lights = ['红','绿','黄']
    let index = 0

    setInterval(()=>{
        console.log(lights[index])
        index = (index + 1) % lights.length
    },1000)
}
```

## 实现LRU缓存

```JavaScript
class LRUCache{
    constructor(length){
        this.length = length
        this.cache = new Map()
    }

    get(key){
        if(!this.cache.has(key)) return
        const value = this.cache.get(key)
        this.cache.delete(key)
        this.cache.set(key,value)
        return value
    }
    put(key,value){
        if(this.cache.has(key)){
            this.cache.delete(key)
        }else if(this.cache.length >= this.length){
            let delKey = this.cache.keys().next().value
            this.cache.delete(delKey)
        }
        this.cache.set(key,value)
    }
}
```

## 将数字每千分位隔开

```JavaScript
let format = n => {
    let num = n.toString()
    let decimals = ''
    num.indexOf('.') > -1 ? decimals = num.split('.')[1] : decimals
    let len = num.length
    if(len<=3){
        return num
    }else{
        let temp = ''
        let remainder = len %3
        decimals ? temp = '.'+decimals:temp
        if(remainder>0){
            return num.slice(0,remainder) + ',' +num.slice(remainder,len).match(/\d{3}/g).join(',')+temp
        }else{
            return num.slice(0,len).match(/\d{3}/g).join(',')+temp
        }
    }
}
console.log(format(12323.33))//12,323.33
```

## 小孩报数问题

```JavaScript
function childNum(num, count) {
  let allplayer = [];
  for (let i = 0; i < num; i++) {
    allplayer[i] = i + 1;
  }
  let exitCount = 0; // 离开人数
  let counter = 0; // 记录报数
  let curIndex = 0; // 当前下标
  while (exitCount < num - 1) {
    if (allplayer[curIndex] !== 0) counter++;
    if (counter === count) {
      allplayer[curIndex] = 0;
      counter = 0;
      exitCount++;
    }
    curIndex++;
    if (curIndex === num) {
      curIndex = 0;
    }
  }
  for (let i = 0; i < num; i++) {
    if (allplayer[i] !== 0) {
      return allplayer[i];
    }
  }
}
```

## CodingMan/LazyMan(链式调用)

```JavaScript
class _CodingMan {
    constructor(name) {
        this.queue = []
        this.sayName(name)
        setTimeout(() => {
            this.next()
        }, 0)
    }
    next() {
        const task = this.queue.shift()
        task && task()
    }
    sayName(name){
        const task = () => {
            console.log(`Hello This is ${name}`)
            this.next()
        }
        this.queue.push(task)
    }
    eat(food) {
        const task = () => {
            console.log(`Eat ${food}`)
            this.next()
        }
        this.queue.push(task)
        return this
    }
    sleep(time) {
        const task = () => {
            setTimeout(() => {
                console.log("sleep~~~")
                this.next()
            }, time * 1000)
        }
        this.queue.push(task)
        return this
    }
    sleepFirst(time) {
        const task = () => {
            setTimeout(() => {
                console.log("sleep first~~~")
                this.next()
            }, time * 1000)
        }
        this.queue.unshift(task)
        return this
    }
}
```

## 实现斐波那契数列

函数使用循环来计算斐波那契数列，从第 2 个数字开始，每次将前两个数字相加得到下一个数字，直到计算出第 n 个数字

```JavaScript
function fibonacci(n) {
  if (n <= 1) {
    return n;
  }

  let a = 0;
  let b = 1;
  let result = 0;

  for (let i = 2; i <= n; i++) {
    result = a + b;
    a = b;
    b = result;
  }

  return result;
}
const n = 10;
const result = fibonacci(n);
console.log(result); // 输出 55
```

## 请求重试

```JavaScript
function retryGet(url, retries, interval) {
  return new Promise((resolve, reject) => {
    const makeRequest = (attempt) => {
      get(url)//请求
        .then(response => {
          resolve(response);
        })
        .catch(error => {
          if (attempt < retries) {//失败时判断请求次数是否达到了最大请求次数限制
            setTimeout(() => {
              makeRequest(attempt + 1);
            }, interval);
            //
          } else {
            reject(error);
          }
        });
    };

    makeRequest(0);//首次将请求次数记录为0
  });
}
```

## 圣杯布局

具有三栏结构的网页布局，有一个主要内容区域和两个侧边栏，这种布局的目的是优先加载主要内容区域，同时保证两个侧边栏跟他有相同的高度。通过使用浮动和负边距来实现

```JavaScript
<body>
    <div class="outer">
        <div class="center"></div>
        <div class="left"></div>
        <div class="right"></div>
    </div>
</body>
<style>
    .outer {
        height: 100px;
        padding-left: 100px;
        padding-right: 200px;
    }

    .left {
        width: 100px;
        height: 100px;
        background-color: aqua;
        position: relative;
        left: -100px;
        float: left;
        margin-left: -100%;
    }

    .right {
        width: 200px;
        height: 100px;
        background-color: blueviolet;
        position: relative;
        left:200px;
        float:right;
        margin-left: -200px;
    }

    .center {
        width: 100%;
        height: 100px;
        background-color: blanchedalmond;
        float: left;
    }
</style>
```

## 双飞翼布局

用于实现具有三个主要区域的页面布局：一个固定宽度的中心内容区域，以及两个自适应宽度的侧边栏

```JavaScript
<div class="container">
  <div class="content">
    <!-- 中心内容区域 -->
  </div>
  <div class="sidebar sidebar-left">
    <!-- 左侧边栏 -->
  </div>
  <div class="sidebar sidebar-right">
    <!-- 右侧边栏 -->
  </div>
</div>
.container {
  margin: 0 auto;
  max-width: 960px;
  overflow: hidden;
}

.content {
  float: left;
  width: 100%;
}

.sidebar {
  float: left;
  width: 200px;
  margin-left: -100%;
}

.sidebar.sidebar-left {
  margin-left: -200px;
}

.sidebar.sidebar-right {
  margin-left: 100%;
}
```

## 16：9纵横比

```JavaScript
  <div class="outer">
    <div class="item"></div>
  </div>
  
 .outer{
    width: 100%;
    height: 0;
    padding-bottom: 56.25%;
    position: relative;
}

.item{
    width: 100%;
    height: 100%;
    position: absolute;
}
//新特性
.outer{
    width: 100%;
}

.item{
    width: 100%;
    aspect-ratio: 16 / 9;
}
```

## 元素拖拽

```JavaScript
var draggableElement = document.getElementById('draggableElement');
var isDragging = false;
var offset = { x: 0, y: 0 };
//当鼠标按下时
draggableElement.addEventListener('mousedown', function(e) {
  isDragging = true;
  offset.x = e.clientX - draggableElement.offsetLeft;//记录当前鼠标位置与元素左边的偏移量
  offset.y = e.clientY - draggableElement.offsetTop;//记录当前鼠标位置与元素上边的偏移量
});

document.addEventListener('mousemove', function(e) {
  if (!isDragging) return;
//在鼠标移动期间，根据鼠标的位置和偏移量计算出元素的新位置
  var x = e.clientX - offset.x;
  var y = e.clientY - offset.y;
  //通过修改元素的 left 和 top 样式来实现拖拽效果
  draggableElement.style.left = x + 'px';
  draggableElement.style.top = y + 'px';
});

document.addEventListener('mouseup', function() {
  isDragging = false;
});
 window.onload = function () {
      //获取drag元素
      let drag = document.getElementById("drag");
      //当鼠标按下时
      drag.onmousedown = function (e) {
        console.log("onmousedown", e);
        console.log("offsetLeft", drag.offsetLeft);
        console.log("offsetTop", drag.offsetTop);
        //做到浏览器兼容
        e = e || window.event;
        // 计算鼠标点击位置相对于元素左上角的左边和上边距离
        let diffX = e.clientX - drag.offsetLeft;

        let diffY = e.clientY - drag.offsetTop;
        //当拉着box移动时
        document.onmousemove = function (e) {
          console.log("onmousemove", e);
          // 浏览器兼容
          e = e || window.event;
          // 元素的 clientX 和 clientY 默认是以元素左上角位置来计算的，这里需要向左向上同时减去鼠标点击的位置差，从而可以保证鼠标始终显示在拖拽元素时的位置
          let left = e.clientX - diffX;
          let top = e.clientY - diffY;
          console.log("left", left);
          console.log("top", top);
          // 边界处理，防止超出各个边
          if (left < 0) {
            left = 0;
          } else if (left > window.innerWidth - drag.offsetWidth) {
            left = window.innerWidth - drag.offsetWidth;
          }
          if (top < 0) {
            top = 0;
          } else if (top > window.innerHeight - drag.offsetHeight) {
            top = window.innerHeight - drag.offsetHeight;
          }
          // 实时给元素定位赋值
          drag.style.left = left + "px";
          drag.style.top = top + "px";
        };

        // 当鼠标抬起时
        document.onmouseup = function (e) {
          console.log("onmouseup", e);
          this.onmousemove = null;
          this.onmouseup = null;
        };
      };
    };
```
