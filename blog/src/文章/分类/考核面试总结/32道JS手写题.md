---
icon: edit
date: 2023-10-24
category:
  - 面试考核总结
tag:
  - 面试题
star: false
sticky: false
copy.disableCopy: true
---

# 32个手写JS，巩固你的JS基础

作为前端开发，JS是重中之重，面对面试高峰期，总结32道手写JS问题，欢迎大家补充

## 01，数组扁平化

数组扁平化是指将一个多维数组变为一个一维数组

```js
const arr = [[2,3,4,5],1,3,4[[1,3,6],1,6],8,9]
// arr = [2,3,4,5,1,3,4,1,3,6,1,6,8,9]
```

### 方法一：使用flat()

```js
const res = arr.flat(Infinity);
```

### 方法二：利用正则

```js
const res = JSON.stringfy(arr).replace(/\[|\]/g,'').split(',')
```

但数据类型都会变成字符串

### 方法三：正则改良版本

```js
const res = JSON.parse('[' + JSON.stringyf(arr).replace(/\[\]/g,'') + ']');
```

### 方法四：使用reduce

```js
const flatten = arr => {
    return arr.reduce((pre,cur) => {
		return pre.concat(Array.isArray(cur) ? flatten(cur) : cur);
    },[])
}
```

### 方法五：函数递归

```js
const res = [];
const fn = arr => {
    for(let i=0;i<arr.length;i++){
        if(Array.isArray(arr[i])){
			fn(arr[i]);
        }else{
            res.push(arr[i]);
        }
    }
}
fn(arr);
```

## 2，数组去重

## 3，限制并发数

```js
function pMap(list, mapper, concurrency = Infinity) {
    // list 为 Iterator，先转化为 Array
    list = Array.from(list)
    return new Promise((resolve, reject) => {
        let currentIndex = 0
        //收集结果的数组
        let result = []
        let resolveCount = 0
        let len = list.length
        function next() {
            const index = currentIndex
            currentIndex++
            Promise.resolve(list[index]).then(o => mapper(o, index)).then(o => {
                result[index] = o
                resolveCount++
                if (resolveCount === len) { resolve(result) }
                if (currentIndex < len) { next() }
            })
        }
        for (let i = 0; i < concurrency && i < len; i ++) {
            next()
        }
    })
}
```

## 4，Promise.all()

```js
// 调用all方法
Promise.myAll = function(proms){
    //返回一个all方法
    return new Promise((res,rej)=>{
        let arr = [];
        //count用来记录all()参数的个数
        let count = 0;
        //fullCount用来记录参数内promise被兑现成功执行的个数，以此作为结束的条件
        let fullCount = 0;
        // for ... of 遍历数组内的所有值（必须用forof，它是所有可迭代对象都可以使用的循环方法）
        for (const item of proms) {
            //保存当前下标，利用闭包保证all()方法内的值的peomirse值按顺序存入arr结果数组
            const i = count;
            count++;
            // then方法放入微任务队列，等待循环全部执行完毕开始执行微任务队列的内容。
            Promise.resolve(item).then(r=>{
                arr[i] = r;
                //用来判断是否所有promise都执行完成
                fullCount++;
                //如果所有promise都执行完成，则执行res方法，将结果数组返回
                if(fullCount === count) {
                    res(arr);
                }
            },rej)
        }
        if(count === 0) res(arr);  
    })
}
```

