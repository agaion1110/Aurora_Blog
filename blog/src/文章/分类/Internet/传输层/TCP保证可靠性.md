---
icon: edit
date: 2023-10-03
category:
  - 学习笔记
  - 计算机网络
tag:
  - 笔记
  - 计算机网络
star: false
sticky: false
copy.disableCopy: true
---

# TCP如何确保可靠性

## 答案：

* **连接管理**：三次握手建立可靠连接
* **校验和**：发送数据的二进制求和取反，接收方以相同方式计算校验和比对，不同就丢弃
* **序列号**：防止数据丢失，避免数据重复，保证有序性
* **确认应答**：接受方收到报文返回ACK，携带确认序列号，告知发送方接收数据的情况，指定时间没收到确认应答就启动超时重传
* **超时重传**：数据包和确认包丢失都会超时重传，接收端收到重复数据会丢弃并回传ACK
* **流量控制**：根据接收方处理能力决定发送端发送速度
* **拥塞控制**：发送端维护一个拥塞窗口

## 三次握手

1. 开始时，客户端和服务端都处于**CLOSE**状态，然后服务端主动监听端口，处于**LISTEN**
2. 客户端会随机初始化序号（client_isn），作为发送序号，同时SYN标志为1，接着把第一个SYN发给服务端，表示向服务端发起连接，不包含数据，之后客户端处于 **SYN_SENT**
3. 服务端收到SYN后，初始化自己的序号（server_isn），作为发送序号，再将确认应答号填入client_isn + 1，把SYN和ACK标为1，把报文发给客户端，报文不包含应用层数据，之后服务端处于 **SYN_RCVD**
4. 客户端收到报文后，向服务端发送最后一个应答报文，ACK1，确认应答号为server_isn + 1，这次报文可以携带客户到服务端的数据，之后客户端处于**ESTABLISHED**
5. 服务端收到ACK后，也进入**ESTABLISHED**状态

**第三次握手可以携带数据**，前两次握手不能携带数据，三次握手后，都处于ESTABLISHED

### 为什么不是两次，四次握手？

因为三次握手可以保证双方都具有接收和发送的能力，主要原因是**三次握手可以防止历史连接的建立，还有是为了同步双方的序列号和避免资源浪费**。

**为什么三次握手**：防止历史连接建立是因为如果客户端先发syn后直接宕机，此时syn被阻塞，重启客户端之后再次发syn，此时服务端先收到了之前阻塞的syn，两个syn的序列号不同，然后服务端返回对旧syn的确认，客户端收到之后发现这个确认号不是自己期望收到的，就会返回RST报文，服务端收到RST就断开连接，新syn到了之后就又会建立连接。

**如果两次握手会造成什么结果：**服务端第一次收到旧syn就可以给客户端发送连接了，虽然客户端会发送RST，但服务端已经把数据发出去了，服务端肯定会建立这个历史连接然后浪费资源发送数据。

同步双方的序列号是因为双方都是一来一回，都要得到应答回应，所以是三次握手；避免资源浪费就是避免2次连接服务端在旧连接基础上直接发送数据，浪费资源。

四次连接是因为没有必要，相当于服务端返回syn和ack分两次


两次握手也可以根据上下文信息丢弃 syn 历史报文，我记着两次握手没有具体实现，应该可以这样。

### 第一次握手丢失会发生什么

客户端建立连接时先发SYN，然后进入**SYN_SENT**状态，之后如果收不到服务端的SYN-ACK，就会触发**超时重传**，重传SYN（序列号也一样），Linux超时重传默认5次，每次超时时间是上一次二倍，总耗时1分钟，次数到最大次数之后，如果在最后超时时间还是没有SYN-ACK，就会在超时时间之后断开连接

### 第二次握手丢失会发生什么

服务端收到客户端第一次握手后，会返回SYN-ACK给客户端，此时服务端进入**SYN_RCVD**状态

第二次握手的SYN-ACK：

* ACK是对第一次握手的确认
* SYN是服务端发起建立TCP连接

如果第二次握手丢失，客户端可能认为自己的SYN丢了，就触发**超时重传**，因为第二次握手包含服务端的SYN，所以当客户端收到后，需要给服务端发送ACK，服务端才认为SYN被客户端收到了，但第二次丢失后，对于服务端，会触发超时重传，重传SYN-ACK，和客户端策略一致

所以当第二次握手丢失，**客户端和服务端都会重传**