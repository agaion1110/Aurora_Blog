---
icon: edit
date: 2023-10-15
category:
  - 计算机网络
tag:
  - 笔记
  - 计算机网络
star: 30930
sticky: false
---

# HTTP各版本的特性

到目前为止，HTTP 常见到版本有 HTTP/1.1，HTTP/2.0，HTTP/3.0，不同版本的 HTTP 特性是不一样的。

<!-- more -->

## HTTP的统一特性

### HTTP的优点

***1.简单***

HTTP基本的报文格式就是`header + body`，头部信息也是`key-value`简单文本的形式，已于理解，降低了学习的和使用的门槛。

***2.灵活和易于扩展***

HTTP协议里的各类请求方法、URI/URL、状态码、头字段等每个组成要求都没有被固定四，都允许开发人员自定义和扩充。

同时HTTP是由于工作在应用层，则它**下层可以随意变化**，比如：

- HTTPS 就是在 HTTP 与 TCP 层之间增加了 SSL/TLS 安全传输层；
- HTTP/1.1 和 HTTP/2.0 传输协议使用的是 TCP 协议，而到了 HTTP/3.0 传输协议改用了 UDP 协议。

***3. 应用广泛和跨平台***

互联网发展至今，HTTP 的应用范围非常的广泛，从台式机的浏览器到手机上的各种 APP，从看新闻、刷贴吧到购物、理财、吃鸡，HTTP 的应用遍地开花，同时天然具有**跨平台**的优越性。

### HTTP的缺点

HTTP 协议里有优缺点一体的**双刃剑**，分别是「无状态、明文传输」，同时还有一大缺点「不安全」。

***1. 无状态双刃剑***

无状态的**好处**，因为服务器不会去记忆 HTTP 的状态，所以不需要额外的资源来记录状态信息，这能减轻服务器的负担，能够把更多的 CPU 和内存用来对外提供服务。

无状态的**坏处**，既然服务器没有记忆能力，它在完成有关联性的操作时会非常麻烦。对于无状态的问题，解法方案有很多种，其中比较简单的方式用 **Cookie** 技术。`Cookie` 通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。

***2. 明文传输双刃剑***

明文意味着在传输过程中的信息，是可方便阅读的，比如抓包都可以直接肉眼查看，为我们调试工作带了极大的便利性。但是这正是这样，HTTP 的所有信息都暴露在了光天化日下。信息的内容都毫无隐私可言，很容易就能被窃取。

***3. 不安全***

HTTP 比较严重的缺点就是不安全：

1. 通信使用明文（不加密），内容可能会被窃听。
2. 不验证通信方的身份，因此有可能遭遇伪装。
3. 不验证通信方的身份，因此有可能遭遇伪装。

HTTP 的安全问题，可以用 HTTPS 的方式解决，也就是通过引入 SSL/TLS 层，使得在安全上达到了极致。

## HTTP/1.1

HTTP 1.1是一种用于在客户端和服务器之间传输数据的协议，它是超文本传输协议（HTTP）的一个版本。HTTP 1.1是对之前的HTTP 1.0版本进行改进和扩展，引入了一些新特性和改进，以提供更高效和可靠的通信。

HTTP/1.1 相比 HTTP/1.0 性能上的改进：

- 使用长连接的方式改善了 HTTP/1.0 短连接造成的性能开销。
  - 早期 HTTP/1.0 性能上的一个很大的问题，那就是每发起一个请求，都要新建一次 TCP 连接（三次握手），而且是串行请求，做了无谓的 TCP 连接建立和断开，增加了通信开销。
  - 为了解决上述 TCP 连接问题，HTTP/1.1 提出了**长连接**的通信方式（`Keep-Alive`），也叫持久连接。这种方式的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。
  - 持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。
  - 当然，如果某个 HTTP 长连接超过一定时间没有任何数据交互，服务端就会主动断开这个连接。
- 支持管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。
  - HTTP/1.1 采用了长连接的方式，这使得管道（pipeline）网络传输成为了可能。
  - 即可在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以**减少整体的响应时间。**
  - 但是**服务器必须按照接收请求的顺序发送对这些管道化请求的响应**。
  -  **HTTP/1.1 管道解决了请求的队头阻塞，但是没有解决响应的队头阻塞**。

但 HTTP/1.1 还是有性能瓶颈：

- 请求 / 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 `Body` 的部分。
- 发送冗长的首部。每次互相发送相同的首部造成的浪费较多；
- 服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是响应的队头阻塞；
- 没有设置请求处理优先级控制；
- 请求只能从客户端开始，服务器只能被动响应。

## HTTP/2

HTTP/2 协议是基于 HTTPS 的，所以 HTTP/2 的安全性也是有保障的。

那 HTTP/2 相比 HTTP/1.1 性能上的改进：

- 头部压缩
  - HTTP/2 会**压缩头**（Header）如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你**消除重复的部分**。
  - 这就是所谓的 `HPACK` 算法：在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就**提高速度**了。
- 二进制格式
  - HTTP/2 不再像 HTTP/1.1 里的纯文本形式的报文，而是全面采用了**二进制格式**，头信息和数据体都是二进制，并且统称为帧（frame）：**头信息帧（Headers Frame）和数据帧（Data Frame）**。
- 并发传输
  - 引出了 Stream 概念，多个 Stream 复用在一条 TCP 连接。**1 个 TCP 连接包含多个 Stream**，**Stream 里可以包含 1 个或多个 Message**，**Message** 对应 HTTP/1 中的请求或响应，**由 HTTP 头部和包体构成。**
  - Message 里包含一条或者多个 Frame，Frame 是 HTTP/2 最小单位，以二进制压缩格式存放 HTTP/1 中的内容（头部和包体）。
  - **针对不同的 HTTP 请求用独一无二的 Stream ID 来区分，接收端可以通过 Stream ID 有序组装成 HTTP 消息，不同 Stream 的帧是可以乱序发送的，因此可以并发不同的 Stream ，也就是 HTTP/2 可以并行交错地发送请求和响应**。
- 服务器主动推送资源
  - HTTP/2 还在一定程度上改善了传统的「请求 - 应答」工作模式，服务端不再是被动地响应，可以**主动**向客户端发送消息。
  - 客户端和服务器**双方都可以建立 Stream**， Stream ID 也是有区别的，客户端建立的 Stream 必须是奇数号，而服务器建立的 Stream 必须是偶数号。

HTTP/2存在的缺陷？

HTTP/2 通过 Stream 的并发能力，解决了 HTTP/1 队头阻塞的问题，看似很完美了，但是 HTTP/2 还是存在“队头阻塞”的问题，只不过问题不是在 HTTP 这一层面，而是在 TCP 这一层。

**HTTP/2 是基于 TCP 协议来传输数据的，TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区里的数据返回给 HTTP 应用，那么当「前 1 个字节数据」没有到达时，后收到的字节数据只能存放在内核缓冲区里，只有等到这 1 个字节数据到达时，HTTP/2 应用层才能从内核中拿到数据，这就是 HTTP/2 队头阻塞问题。**

## HHTP/3

HTTP/3是一种用于网络通信的协议，它是HTTP协议的最新版本，也被称为"HTTP over QUIC"或"HTTP/QUIC"。HTTP/3在传输层使用了QUIC（Quick UDP Internet Connections）协议，旨在提供更快的连接建立和数据传输速度，以及更好的性能和安全性。

前面我们知道了 HTTP/1.1 和 HTTP/2 都有队头阻塞的问题：

- HTTP/1.1 中的管道（ pipeline）虽然解决了请求的队头阻塞，但是**没有解决响应的队头阻塞**，因为服务端需要按顺序响应收到的请求，如果服务端处理某个请求消耗的时间比较长，那么只能等响应完这个请求后， 才能处理下一个请求，这属于 HTTP 层队头阻塞。
- HTTP/2 虽然通过多个请求复用一个 TCP 连接解决了 HTTP 的队头阻塞 ，但是**一旦发生丢包，就会阻塞住所有的 HTTP 请求**，这属于 TCP 层队头阻塞。

HTTP/2 队头阻塞的问题是因为 TCP，所以 **HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP！**

UDP 发送是不管顺序，也不管丢包的，所以不会出现像 HTTP/2 队头阻塞的问题。大家都知道 UDP 是不可靠传输的，但基于 UDP 的 **QUIC 协议** 可以实现类似 TCP 的可靠性传输。

QUIC 有以下 3 个特点。

- 无队头阻塞
- 更快的连接建立
- 连接迁移

***1、无队头阻塞***

QUIC 协议也有类似 HTTP/2 Stream 与多路复用的概念，也是可以在同一条连接上并发传输多个 Stream，Stream 可以认为就是一条 HTTP 请求。

QUIC 有自己的一套机制可以保证传输的可靠性的。**当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响，因此不存在队头阻塞问题**。这与 HTTP/2 不同，HTTP/2 只要某个流中的数据包丢失了，其他流也会因此受影响。

所以，QUIC 连接上的多个 Stream 之间并没有依赖，都是独立的，某个流发生丢包了，只会影响该流，其他流不受影响。

***2、更快的连接建立***

对于 HTTP/1 和 HTTP/2 协议，TCP 和 TLS 是分层的，分别属于内核实现的传输层、openssl 库实现的表示层，因此它们难以合并在一起，需要分批次来握手，先 TCP 握手，再 TLS 握手。

HTTP/3 在传输数据前虽然需要 QUIC 协议握手，但是这个握手过程只需要 1 RTT，握手的目的是为确认双方的「连接 ID」，连接迁移就是基于连接 ID 实现的。

***3、连接迁移***

基于 TCP 传输协议的 HTTP 协议，由于是通过四元组（源 IP、源端口、目的 IP、目的端口）确定一条 TCP 连接。

那么**当移动设备的网络从 4G 切换到 WIFI 时，意味着 IP 地址变化了，那么就必须要断开连接，然后重新建立连接**。

而 QUIC 协议没有用四元组的方式来“绑定”连接，而是通过**连接 ID** 来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本，没有丝毫卡顿感，达到了**连接迁移**的功能。

### 总结：

1. 基于UDP：HTTP/3使用QUIC作为传输层协议，而不是HTTP/1.1和HTTP/2中使用的TCP协议。QUIC基于UDP协议，它在传输层提供了更快的连接建立和数据传输速度。相较于TCP，QUIC减少了握手的延迟，并通过多路复用和快速重传等机制提供了更好的数据传输性能。
2. 多路复用：HTTP/3支持在单个连接上进行多路复用，这意味着可以同时发送多个请求和接收多个响应，而无需等待之前的请求完成。多路复用减少了连接的开销和延迟，提高了并发请求的效率。
3. 0-RTT连接恢复：HTTP/3允许使用0-RTT（Zero Round Trip Time）连接恢复机制，这意味着客户端可以在重新建立连接时发送的第一个请求上携带先前的加密上下文，从而减少了握手的延迟。这对于断开连接后的快速恢复和改善性能非常有用。
4. 更好的拥塞控制：HTTP/3采用了更先进的拥塞控制算法，通过更准确地检测和响应网络拥塞情况，提高了网络的稳定性和传输效率。
5. 改进的安全性：HTTP/3默认使用TLS 1.3来加密通信，提供了更强的安全性和隐私保护。同时，由于QUIC协议在传输层提供了加密和认证功能，HTTP/3可以更早地建立安全连接，减少了握手的延迟。
