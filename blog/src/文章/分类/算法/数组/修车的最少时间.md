---
icon: edit
date: 2023-09-07
category:
  - 算法
tag:
  - leetcode
star: false
sticky: false
pageview: true
copy.disableCopy: true
---

#  修车的最少用时

## 题目

给你一个整数数组 `ranks` ，表示一些机械工的 **能力值** 。`ranksi` 是第 `i` 位机械工的能力值。能力值为 `r` 的机械工可以在 `r * n2` 分钟内修好 `n` 辆车。

同时给你一个整数 `cars` ，表示总共需要修理的汽车数目。

请你返回修理所有汽车 **最少** 需要多少时间。

**注意：**所有机械工可以同时修理汽车。

<!-- more -->

**示例 1：**

```
输入：ranks = [4,2,3,1], cars = 10
输出：16
解释：
- 第一位机械工修 2 辆车，需要 4 * 2 * 2 = 16 分钟。
- 第二位机械工修 2 辆车，需要 2 * 2 * 2 = 8 分钟。
- 第三位机械工修 2 辆车，需要 3 * 2 * 2 = 12 分钟。
- 第四位机械工修 4 辆车，需要 1 * 4 * 4 = 16 分钟。
16 分钟是修理完所有车需要的最少时间。
```

**示例 2：**

```
输入：ranks = [5,1,8], cars = 6
输出：16
解释：
- 第一位机械工修 1 辆车，需要 5 * 1 * 1 = 5 分钟。
- 第二位机械工修 4 辆车，需要 1 * 4 * 4 = 16 分钟。
- 第三位机械工修 1 辆车，需要 8 * 1 * 1 = 8 分钟。
16 分钟时修理完所有车需要的最少时间。
```

## 解题思路

本地用到了双指针法，通过阅读题目我们可以找出这样的规律。

- 假设t分钟内能把所有的汽车都修理完，那么大于等于t分钟内都可以将汽车修完。
- 假设t分钟内不能把所有汽车都修理完，那么小于等于t分钟内也不能将所有汽车都修完。

所以题目要求解修理汽车所需的最少时间，故先考虑二分是否可行，如上面的规律可以看出解的值范围内有单调性，就可以使用二分。

我们可以理解假设一个时间t，那么能力值为r的工人可以修完`Math.sqrt(t/r)`辆汽车，那么当所有工人所修汽车数量和大于cars时，则可以调整右边界为t，否则调整左边界为t+1。

二分的上上界可以取正无穷，也可以取任意一个工人修完所有车辆的所需时间。因为我们最终的目的是根据所取时间的移动最终找到符合条件的最小值。

```js
var repairCars = function(ranks, cars) {
    //定义左右指针，左值针指向最小时间或1，右指针指向正无穷或者随机一个工人修完所有车需要的时间(这个值无关紧要，因为找不到合适的值，下一次循环会自动匹配一个新的值，直到找到最小时间即结果)
    let left=1,right=Number.MAX_SAFE_INTEGER;
    // 这个函数用来判断工人在是该时间内能否保证修完所有的车
    const check = (t)=>{
        let sum = 0;
        for(const x of ranks){
            //分析时我们知道每个工人在t时内能修的车的个数为(Math.sqrt(t/x))，循环求和即得到修车总数。
            sum+=Math.floor(Math.sqrt(t/x));
        }
        return sum>=cars;
    }
    //左右指针开始移动，直到左右指针相等，即左值针从小变大刚刚达到可以修完所有车的最小时间
    while(left<right){
        //取中间值
        const m = Math.floor((left+right)/2);
        //对该时间进行判断
        if(check(m)){
            //如果判断该时间内可以修完所有车，那么说明最小时间在该时间之前或者它本身，左移右指针，缩小范围。
            right = m;
        }else{
            //如果判断该时间内不能修完所有的车，那么说明最小时间在该时间之后，右移左值针且只能移动一个单位时间。
            left = m+1;
        }
    }
    return left;
};
```





