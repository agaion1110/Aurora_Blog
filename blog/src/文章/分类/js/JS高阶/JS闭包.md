---
icon: edit
date: 2023-09-12
category:
  - js
tag:
  - js基础
  - 面试题
star: 3912
sticky: true
copy.disableCopy: true
---

# JS的闭包

## 前提 | 执行上下文

### 执行上下文的定义

在了解什么是闭包之前，我们首先要先了解什么是执行上下文`context`。`context`即中文意思有执行上下文、背景、环境的意思。

> 执行上下文的定义：执行上下文（Execution context）是指在程序执行过程中，用于存储和管理变量、函数、对象和其他执行相关信息的内部数据结构。它是为了支持程序的顺序执行和正确性而存在的。每当 JavaScript 代码执行时，就会创建一个执行上下文。

`JavaScript`运行环境也叫做执行上下文，因此在一个`JavaScript`程序中，必定会出现多个执行上下文。JS引擎会以栈的方式来处理执行上下文。**栈底**永远是**全局上下文**，**栈顶**则是当前**正在执行的上下文。** 处于栈顶的执行上下文执行完毕后，会自动出栈。

### 执行上下文的组成

执行上下文包含了以下重要组成部分：

1. 变量对象（Variable object）：变量对象是一个存储变量、函数声明和函数参数的容器。它在执行上下文创建时被初始化，并根据代码中的变量和函数声明进行填充。在 JavaScript 中，变量对象可以是词法环境或全局对象。
2. 作用域链（Scope chain）：作用域链是一个由多个变量对象组成的链表。它用于解析变量和函数的标识符。当在当前变量对象中找不到标识符时，引擎会沿着作用域链向上查找，直到找到为止。作用域链的头部是当前执行上下文的变量对象。
3. this 值（This value）：this 值指向当前执行上下文所关联的对象。它的具体值取决于函数的调用方式。在全局执行上下文中，this 指向全局对象（例如 window 对象）。在函数执行上下文中，this 的值根据函数的调用方式来确定。

### 执行上下文的分类

执行上下文有三种类型：

1. 全局执行上下文（`Global`）：当代码开始执行时，全局执行上下文被创建。它是整个代码中最外层的执行上下文，并且在整个代码执行期间一直存在。全局执行上下文包含全局对象（例如 `window` 对象在浏览器环境中）以及全局范围内定义的变量和函数。
2. 函数执行上下文（`Function`）：每当执行到一个函数时，函数执行上下文就被创建。函数执行上下文与对应的函数关联，并且在函数执行期间存在。函数执行上下文具有函数的参数，局部变量，内部函数等。每次调用函数都会创建一个新的函数执行上下文。
3. Eval 函数执行上下文（`Eval`）：当执行 `eval` 函数时，会创建一个 Eval 函数执行上下文。`eval` 函数是 `JavaScript` 中的一个特殊函数，用于执行动态的 `JavaScript` 代码。Eval 函数执行上下文被创建后，会在它自己的作用域中执行动态代码。由于`eval`函数存在很多问题，如果我们对`eval`函数了解不够深入不建议使用。

### 执行上下文

我们从一道例题入手：

```html
<script>
function a() {
    b()
    function b() {
        c();
        function c() {
            console.log('c的执行上下文')
        }
    }
}
a();
</script>
```

JS是一门单线程的脚本语言，在JS渲染引擎中用栈来一步步解析代码。

> 第一步：全局执行上下文入栈
>
> 第二步：全局上下文入栈后，遇到第一个可执行的代码就是`a()`的调用，此函数一经调用就会产生函数a的执行上下文，将a函数的执行上下文入栈。
>
> 第三步：在新开辟的执行上下文中发现可以执行的代码`b()`,此时又会产生函数b的执行上下文并入栈。
>
> 第四步：同理在新开辟的执行上下文中又有调用`c()`的代码执行，并产生函数c的执行上下文入栈
>
> 第五步：在新开辟的执行上下文中执行`console.log('c的执行上下文')`后发现没有新的环境（执行上下文），弹出栈顶c的执行上下文。
>
> 第六步：c的执行上下文弹出后会继续执行 b执行上下文中的可执行代码，直到顺利执行完毕，且没有遇到其他执行上下文，则自动从栈中弹出。
>
> 第七步：b的执行上下文弹出后会继续执行 a执行上下文中的可执行代码，直到顺利执行完毕，且没有遇到其他执行上下文，则自动从栈中弹出。
>
> 第八步：最后执行栈中只剩下全局上下文，若浏览器不关闭，全局上下文会一直存在，直到浏览器窗口关闭，全局上下文才会最终出栈。

### 执行上下文的生命周期

每个执行上下文都具有创建、进入和退出三个阶段。

1. 创建阶段：
   - 创建变量对象: 在这个阶段，JavaScript 引擎会为当前执行上下文创建一个变量对象，用来存储变量和函数的声明。变量对象包括函数参数、函数声明、变量声明以及由 `let` 和 `const` 声明的变量（但未进行赋值）。
   - 建立作用域链: 在创建阶段，JavaScript 引擎会创建作用域链，用来解析变量的标识符。作用域链由当前执行上下文的变量对象和所有包含的父级作用域的变量对象组成。
   - 确定 `this` 的指向: 在创建阶段，JavaScript 引擎会根据函数的调用方式确定 `this` 的指向。对于全局执行上下文来说，`this` 指向全局对象（如 `window` 对象）；对于函数执行上下文来说，`this` 的值在函数调用时被确定。
2. 执行阶段:
   - 分配变量/函数内存空间: 在执行阶段，JavaScript 引擎会为变量分配内存空间，并将其初始化为 `undefined`。同时，函数声明会被编译器提前，使其可以在代码中的任何位置调用。
   - 顺序执行代码: 在执行阶段，JavaScript 引擎会按照代码的顺序一行一行地执行。当遇到函数调用时，会创建一个新的执行上下文并推入调用栈，开始执行被调用的函数。
   - 标识符解析: 在执行阶段，JavaScript 引擎会根据作用域链来解析变量的标识符。它会从当前执行上下文的变量对象开始查找，如果找不到会继续查找父级作用域的变量对象。
3. 销毁阶段：
   - 执行上下文的销毁: 当代码执行完成或函数调用结束时，当前执行上下文会被销毁。任何在执行上下文中创建的变量和函数的引用都会被释放。
   - 内存回收: 在执行上下文销毁后，变量和函数占用的内存空间会被垃圾回收

## 闭包

我们来看下面这段代码执行的结构输出是多少：

```js
 1: function Counter() {
 2:   let count = 0
 3:   const fn = function() {
 4:     count = count + 1
 5:     return count
 6:   }
 7:   return fn
 8: }
 9: const increment = Counter()
10: const c1 = increment()
11: const c2 = increment()
12: const c3 = increment()
13: console.log(c1, c2, c3)
```

答案是：1，2，3

> 解析：
>
> - 第一步：创建全局上下文，并在全局执行上下文中创建了一个新的变量`Counter`，它得到了指定的函数定义。
> - 第二步：然后继续在全局执行上下文中声明了一个名为`increment`的新变量。
> - 第三步：紧接着调用`Counter`函数并将其返回值赋给`increment`变量，由于调用了`Counter`函数，创建新的本地执行上下文。
> - 第四步：在本地执行上下文中，声明一个名为`count`的新变量并赋值为 `0` 。
> - 第五步：声明一个名为`fn`的新变量，变量在本地执行上下文中声明，变量的内容是另一个函数定义。
> - 第六步：返回`fn`变量的内容`count`，销毁本地执行上下文。`fn`和`count`不再存在。控制权交给了调用上下文，我们返回函数定义和它的闭包，闭包中包含了创建它时在作用域内的变量。
> - 第七步：在调用上下文(全局执行上下文)中，`Counter`返回的值被指定为`increment`，变量`increment`现在包含一个函数定义(和闭包),由`Counter`返回的函数定义，它不再标记为`fn`，但它的定义是相同的,在全局上下文中，称为`increment`。
> - 第八步：在全局执行上下文中，按顺序声明c1、c2、c3变量，并调用increment变量，它们都会创建一个各自的本地执行上下文。
> - 第九步：变量c1、c2、c3在自己创建的本地执行上下文中执行代码`count = count + 1`，在调用本地执行上下文之前，会先检查闭包即，我们发现`count`值被储存在闭包环境中，于是调用执行上下文之外闭包中的变量值并执行加1的操作，这样待本地执行上下文执行阶段完毕后，在各自销毁阶段销毁自己的本地执行上下文并返回`count`。
> - 第十步：得到答案：1、2、3

## 总结

其实闭包并没有我们想象的那般复杂，闭包是一个关于作用域链的概念；

JS执行环境，你的全局作用域（`window`）是最大的作用域，你可以定义很多块级作用域。因为销毁全局作用域是你整个页面停止和关闭；所以**每个函数内部都可以看作一个作用域**，当函数内部返回一个函数且子函数没在父级作用域内完成整个生命周期的话，父级函数是没办法完成一整个生命周期的，闭包正是利用这一点卡住了父级函数的作用域， 如果你在父级函数中子函数执行完成返回一个基本类型的话是没办法卡住父级作用域的生命周期的。

提到闭包，没必要去纠结，直接**回答函数嵌套函数，且内部函数调用父级作用域的变量就可以称之为闭包了**。因为JS作用域生命名周期在于内部脚本是否全部执行完毕才会销毁，并且不会带到父级作用域；滥用闭包为什么存在内存泄漏的问题正是由于反复的，且频繁的使用闭包。

::: tip

**闭包是引用了其他函数作用域变量的函数**

:::